<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Quoridor AI</title>
    <url>/2022/07/15/Quoridor-AI/</url>
    <content><![CDATA[<p>本文是夏季学期PPCA课程Project 2: Quoridor AI的README，具体代码见<a href="https://github.com/MeteorVanish/Quoridor-AI">Github仓库</a></p>
<span id="more"></span>
<h1 id="quoridor-ai">Quoridor AI</h1>
<h2 id="简介">简介</h2>
<ul>
<li>上海交通大学，2021级CS，MeteorVanish</li>
<li>2021-2022学年夏季学期，PPCA Project 2</li>
<li>用 C++ 实现棋类游戏 <code>Quoridor</code> 的简易AI</li>
<li>使用算法：<code>Minimax + Alpha-beta Pruning</code> /
<code>Monte Carlo Tree Search</code></li>
</ul>
<h2 id="游戏介绍">游戏介绍</h2>
<h3 id="基本玩法">基本玩法</h3>
<p><a href="https://en.wikipedia.org/wiki/Quoridor">Quoridor</a>，中文名为步步为营或是墙棋。棋盘由9×9的格子构成，格子间有凹槽。游戏双方各有一枚1×1的棋子，初始位于上下底边中间；各有10片长度为2格的木板（墙），可放置在凹槽中。玩家每一步可以向四个方向移动一格棋子或是放置一片木板，率先抵达对方底线的玩家获胜。</p>
<h3 id="细节规则">细节规则</h3>
<ul>
<li><strong>移动</strong><br>
玩家移动方向不能有墙阻挡（边界也算墙），若移动方向被对方棋子阻挡，在对方身后没有墙阻挡的情况下，可以跳过对方棋子，否则可以跳到对方棋子左右两侧（左右两侧没有墙阻挡）</li>
<li><strong>放墙</strong><br>
木板之间不能重叠或交叉，每一片木板放置后须保证双方棋子均存在一条抵达对方底线的路线</li>
</ul>
<h3 id="游戏特点">游戏特点</h3>
<ul>
<li>与围棋、象棋等棋类游戏一样，为Combinatorial
Game，即具有<strong>零和</strong>（zero-sum），<strong>透明信息</strong>（fully
information），<strong>确定性</strong>（determinism），顺序性（sequential），<strong>离散性</strong>（discrete）这些特点，因此适合用
<code>Minimax</code> 或是 <code>MCTS</code>
这两种算法，来逼近博弈过程的纳什均衡点。</li>
</ul>
<h2 id="文件内容">文件内容</h2>
<ul>
<li><strong><code>down</code>
文件夹</strong>：助教下发的所有内容，包括项目要求、代码框架、本地评测程序和学习资料</li>
<li><strong><code>src</code>
文件夹</strong>：实现两种算法的AI源程序</li>
<li><strong><code>exe</code> 文件夹</strong>：两种算法在
<code>Windows</code> 下编译的 <code>exe</code>
文件、助教下发的评测程序</li>
</ul>
<h2 id="如何运行">如何运行</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">py judge.py &quot;human/AI name 1&quot; &quot;human/AI name 2&quot;</span><br></pre></td></tr></table></figure>
<p><em>（注：运行评测程序需要本地安装 <code>python</code> 的
<code>numpy</code> 库）</em></p>
<h3 id="示例">示例</h3>
<ul>
<li>两种不同算法AI对战
<code>py judge.py "Yosoro! [minimax].exe" "Yosoro! [MCTS].exe"</code></li>
<li>人人对战 <code>py judge.py human human</code></li>
<li>人机对战（先手）
<code>py judge.py human "Yosoro! [minimax].exe"</code></li>
</ul>
<h2 id="代码框架">代码框架</h2>
<p>见 <code>down\sample.cpp</code> 文件</p>
<ul>
<li><code>init()</code> 函数：在对局开始前调用一次</li>
<li><code>action()</code>函数：接受对方操作
<code>loc</code>，返回己方操作，操作码含义见
<code>down\README.pdf</code> 文件</li>
</ul>
]]></content>
      <categories>
        <category>CS学习之路</category>
      </categories>
  </entry>
  <entry>
    <title>RISC-V Simulator</title>
    <url>/2022/07/02/RISC-V-Simulator/</url>
    <content><![CDATA[<p>本文是夏季学期PPCA课程Project 1: RISC-V
Simulator的README，具体代码见<a href="https://github.com/MeteorVanish/RISC-V-Simulator">Github仓库</a></p>
<span id="more"></span>
<h1 id="risc-v-simulator">RISC-V Simulator</h1>
<h2 id="简介">简介</h2>
<ul>
<li>上海交通大学，2021级CS，MeteorVanish</li>
<li>2021-2022学年夏季学期，PPCA Project 1</li>
<li>用 C++ 模拟 CPU 五级流水，使用 <code>RISC-V</code> 指令集</li>
</ul>
<h2 id="实现成果">实现成果</h2>
<ul>
<li>各阶段可乱序执行（模拟硬件并行）</li>
<li>通过 <code>Forwarding</code> 尽量避免
<code>Stall</code>，减少时钟周期</li>
<li>采用混合分支预测，平均准确率为
<code>80.94%</code>（详见后文各测试点预测准确率）</li>
</ul>
<h2 id="五级流水">五级流水</h2>
<h3 id="架构设计图">架构设计图</h3>
<p><img src="/2022/07/02/RISC-V-Simulator/Pipeline_Architecture.png"></p>
<h3 id="各阶段说明">各阶段说明</h3>
<ul>
<li><code>IF (Instruction Fetch)</code>
<ul>
<li>消耗一个时钟周期</li>
<li>内存中读取指令，分支预测</li>
</ul></li>
<li><code>ID (Instruction Decode)</code>
<ul>
<li>消耗一个时钟周期</li>
<li>指令解码，读取寄存器</li>
</ul></li>
<li><code>EX (EXecute)</code>
<ul>
<li>消耗一个时钟周期</li>
<li>获取计算结果、目标内存地址（Load/Store）、下条指令地址（Jump/Branch），更新预测器</li>
</ul></li>
<li><code>MEM (MEMory access)</code>
<ul>
<li><code>Load/Store</code>
指令消耗三个时钟周期，其余消耗一个时钟周期</li>
<li>写入/读取内存地址（Load/Store）</li>
</ul></li>
<li><code>WB (Write Back)</code>
<ul>
<li>消耗一个时钟周期</li>
<li>写入寄存器</li>
</ul></li>
</ul>
<h3 id="缩写说明">缩写说明</h3>
<table>
<thead>
<tr class="header">
<th style="text-align: center;"><strong>缩写</strong></th>
<th style="text-align: center;"><strong>全称</strong></th>
<th style="text-align: center;"><strong>含义</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">PC</td>
<td style="text-align: center;">Program Counter</td>
<td style="text-align: center;">指令地址</td>
</tr>
<tr class="even">
<td style="text-align: center;">INS</td>
<td style="text-align: center;">Instuction</td>
<td style="text-align: center;">指令</td>
</tr>
<tr class="odd">
<td style="text-align: center;">OPCODE</td>
<td style="text-align: center;">Operation Code</td>
<td style="text-align: center;">指令操作码</td>
</tr>
<tr class="even">
<td style="text-align: center;">IMM</td>
<td style="text-align: center;">Immediate</td>
<td style="text-align: center;">立即数</td>
</tr>
<tr class="odd">
<td style="text-align: center;">RS</td>
<td style="text-align: center;">Register Source</td>
<td style="text-align: center;">来源寄存器编号</td>
</tr>
<tr class="even">
<td style="text-align: center;">RV</td>
<td style="text-align: center;">Register Value</td>
<td style="text-align: center;">来源寄存器的值</td>
</tr>
<tr class="odd">
<td style="text-align: center;">RD</td>
<td style="text-align: center;">Register Destination</td>
<td style="text-align: center;">目标寄存器编号</td>
</tr>
<tr class="even">
<td style="text-align: center;">AD</td>
<td style="text-align: center;">Address Destination</td>
<td style="text-align: center;">目标地址</td>
</tr>
<tr class="odd">
<td style="text-align: center;">EXR</td>
<td style="text-align: center;">Execution Result</td>
<td style="text-align: center;">计算结果</td>
</tr>
</tbody>
</table>
<h2 id="问题及解决方案">问题及解决方案</h2>
<ul>
<li><code>Data Hazard</code>
<ul>
<li><strong>问题：</strong> 当前指令的 <code>rs</code> 是前三条指令的
<code>rd</code> （尚未将新值写入寄存器）</li>
<li><strong>解决方案：</strong>
<strong>Forwarding</strong>，即将之前指令计算后存在对应
<code>Buffer</code> 中的值复制到当前指令的 <code>Buffer</code> 中</li>
<li><strong>问题：</strong> 当前指令的 <code>rs</code>
是上条指令（Load）的 <code>rd</code> （尚未从内存中读取寄存器的值）</li>
<li><strong>解决方案：</strong> <strong>Stall</strong>，即将
<code>IF、ID、EX</code> 暂停一个时钟周期，对应 <code>Buffer</code>
的值保留</li>
</ul></li>
<li><code>Control Hazard</code>
<ul>
<li><strong>问题：</strong> 分支预测结果错误</li>
<li><strong>解决方案：</strong> <strong>Discard</strong>，即将
<code>IF/ID.Buffer</code> 中的值清空，更新下条指令地址</li>
</ul></li>
</ul>
<h2 id="文件结构">文件结构</h2>
<ul>
<li><strong>main.cpp</strong>
<ul>
<li><code>main</code> 函数</li>
</ul></li>
<li><strong>CPU.hpp</strong>
<ul>
<li><code>CPU</code> 类
<ul>
<li><strong>成员变量</strong>
<ul>
<li>内存对象、寄存器对象、预测器对象、五阶段对象、五阶段
<code>Buffer</code>、<code>pc</code>、<code>pcNext</code>、各种
<code>Flag/Cnt</code></li>
</ul></li>
<li><strong>成员函数</strong>
<ul>
<li><code>run()</code>：模拟时钟周期乱序执行五阶段（模拟五阶段并行）</li>
</ul></li>
</ul></li>
</ul></li>
<li><strong>Stage.hpp</strong>
<ul>
<li><code>stageIF/ID/EX/MEM/WB</code> 类
<ul>
<li><strong>成员变量</strong>
<ul>
<li><code>Buffer</code>、<code>NOPFlag</code>以及一些CPU成员变量的引用</li>
</ul></li>
<li><strong>成员函数</strong>
<ul>
<li><code>execute()</code>：执行各阶段功能，得到 <code>Buffer</code>
数据</li>
</ul></li>
</ul></li>
</ul></li>
<li><strong>Memory.hpp</strong>
<ul>
<li><code>Memory</code> 类
<ul>
<li><strong>成员变量</strong>
<ul>
<li><code>Data[]</code>
<ul>
<li>每一位存1 Byte的数据的数组</li>
</ul></li>
</ul></li>
<li><strong>成员函数</strong>
<ul>
<li><code>构造函数</code>：读取输入数据存入 <code>Data</code> 中</li>
<li><code>Load()</code>：读取 <code>pos</code> 开始 <code>len</code>
个Byte的数据</li>
<li><code>Store()</code>：将 <code>val</code> 写入 <code>pos</code> 开始
<code>len</code> 个Byte中</li>
</ul></li>
</ul></li>
</ul></li>
<li><strong>Register.hpp</strong>
<ul>
<li><code>RegTable</code>
<ul>
<li><code>RISC-V</code> 寄存器名称表</li>
</ul></li>
<li><code>Register</code> 类
<ul>
<li><strong>成员变量</strong>
<ul>
<li><code>Data[32]</code>
<ul>
<li>32个32位寄存器</li>
</ul></li>
</ul></li>
<li><strong>成员函数</strong>
<ul>
<li><code>Load()</code>：读取第 <code>index</code> 个寄存器的数据</li>
<li><code>Store()</code>：将 <code>val</code> 写入第 <code>index</code>
个寄存器中（特判zero寄存器不可修改）</li>
</ul></li>
</ul></li>
</ul></li>
<li><strong>Buffer.hpp</strong>
<ul>
<li><code>IF/ID/EX/MEM/WB_Buffer</code> 结构体
<ul>
<li><strong>成员变量</strong>
<ul>
<li>对应阶段需保存的数据（确保可以乱序执行）</li>
</ul></li>
<li><strong>成员函数</strong>
<ul>
<li><code>Clear()</code>：清空 <code>Buffer</code></li>
</ul></li>
</ul></li>
</ul></li>
<li><strong>Predictor.hpp</strong>
<ul>
<li><code>Predictor</code> 类
<ul>
<li><strong>成员变量</strong>
<ul>
<li><code>TotalNum</code>,<code>CorrectNum</code>
<ul>
<li>用于记录预测准确率</li>
</ul></li>
<li><code>Counter[]</code>
<ul>
<li>记录指令的预测次数，用于决策预测方法</li>
</ul></li>
<li><code>BTB[]</code>
<ul>
<li>Branch Target Buffer，记录跳转地址</li>
</ul></li>
<li><code>BHT[]</code>
<ul>
<li>Branch History Table，记录历史跳转模式</li>
</ul></li>
<li><code>PHT[][]</code>
<ul>
<li>Pattern History Table，每条指令特定模式的四位饱和计数器</li>
</ul></li>
<li><code>TwoBitCounter[]</code>
<ul>
<li>每条指令简单的四位饱和计数器</li>
</ul></li>
</ul></li>
<li><strong>成员函数</strong>
<ul>
<li><code>构造函数</code>：初始化将所有四位饱和设置为
<code>not taken</code> 情况下的最大值，将 <code>BTB[]</code> 设置为对应
<code>pc</code> 地址+4</li>
<li><code>NextPredict()</code>：预测下条指令地址，修改
<code>pcNext</code> 和 <code>pcPredict</code> 的值</li>
<li><code>Update()</code>：根据 <code>EX</code>
阶段得到的跳转地址更新预测器</li>
<li><code>PrintResult()</code>：用于输出预测准确率</li>
</ul></li>
</ul></li>
</ul></li>
<li><strong>Instruction.hpp</strong>
<ul>
<li><code>InsTable</code>
<ul>
<li><code>RISC-V</code> 指令名称表</li>
</ul></li>
<li><code>enum INS_TYPE</code>
<ul>
<li><code>RISC-V</code> 指令名称枚举</li>
</ul></li>
<li><code>Is___()</code>
<ul>
<li>指令类型判断</li>
</ul></li>
<li><code>SignExtend()</code>
<ul>
<li>指令符号位扩展</li>
</ul></li>
<li><code>InsDecode()</code>
<ul>
<li>指令解码，获得
<code>InsType</code>，<code>rd</code>，<code>imm</code>，<code>rs1</code>，<code>rs2</code>，<code>RegNum</code></li>
</ul></li>
</ul></li>
<li><strong>LocalTest.hpp</strong>
<ul>
<li>在OJ上评测时注释 <code>CPU.hpp</code> 中的
<code>#include "LocalTest.h"</code> 即可 <code>AC</code></li>
<li><code>#define RISC_V_DEBUG</code>
<ul>
<li>取消注释会打印每个测试点每个时钟周期结束后寄存器与
<code>Buffer</code> 中的数据</li>
</ul></li>
<li><code>#define RISC_V_PRINT</code>
<ul>
<li>取消注释会打印每个测试点总时钟周期、分支预测总数、正确数和准确率</li>
</ul></li>
<li><code>FileTable</code>
<ul>
<li>测试点文件名称表</li>
</ul></li>
<li><code>AnsTable</code>
<ul>
<li>测试点答案表</li>
</ul></li>
</ul></li>
</ul>
<h2 id="分支预测">分支预测</h2>
<h3 id="具体方法">具体方法</h3>
<p>在 <code>IF</code> 阶段以 <code>pc</code> 为依据进行分支预测，在
<code>EX</code> 阶段根据跳转结果更新分支预测器</p>
<ul>
<li><strong>四位饱和计数器预测</strong>
<ul>
<li><strong>实现：</strong>
<ul>
<li><code>IF</code>：通过 <code>BTB[]</code> 获得分支跳转地址，通过
<code>FourBitCounter[]</code> 判断是否跳转</li>
<li><code>EX</code>：第一次跳转时更新 <code>BTB[]</code>，每次更新
<code>FourBitCounter[]</code></li>
</ul></li>
</ul></li>
<li><strong>二级自适应预测</strong>
<ul>
<li><strong>实现：</strong>
<ul>
<li><code>IF</code>：通过 <code>BTB[]</code> 获得分支跳转地址，通过
<code>BHT[]</code> 获得历史跳转模式，通过 <code>PHT[][]</code>
判断是否跳转</li>
<li><code>EX</code>：第一次跳转时更新 <code>BTB[]</code>，每次更新
<code>BHT[]</code> 和对应的 <code>PHT[][]</code></li>
</ul></li>
</ul></li>
<li><strong>混合分支预测</strong>
<ul>
<li><strong>思路：</strong>
二级自适应预测能够对不同的历史跳转模式记录饱和计数器，这在预测数多的情况下，能记录更多的历史跳转信息，相比饱和计数器预测更有针对性，
准确率占优势，但在预测数较少的情况下，每种模式第一次跳转都将预测失败，反而导致准确率降低，因此选择一条标准线，对每条指令而言，预测数量超过标准线
后再采用二级自适应预测，否则采用四位饱和计数器预测，这样兼顾了前两种预测方法的优点，综合预测准确率有一定的提升。</li>
<li><strong>实现：</strong>
<ul>
<li><code>IF</code>：当 <code>Counter[]</code> 大于
<code>SWITCH_THRESHOLD</code>
时采用二级自适应预测，否则采取四位饱和计数器预测</li>
<li><code>EX</code>：第一次跳转时更新 <code>BTB[]</code>，每次更新
<code>Counter[]</code>，并同时更新 <code>FourBitCounter[]</code> 和
<code>BHT[]</code>，<code>PHT[][]</code></li>
</ul></li>
</ul></li>
</ul>
<h3 id="预测准确率">预测准确率</h3>
<ul>
<li><strong>静态预测（始终跳转）</strong>（平均预测准确率：<code>55.29%</code>）</li>
</ul>
<table>
<colgroup>
<col style="width: 27%">
<col style="width: 18%">
<col style="width: 18%">
<col style="width: 18%">
<col style="width: 16%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;"><strong>测试点</strong></th>
<th style="text-align: center;"><strong>时钟周期数</strong></th>
<th style="text-align: center;"><strong>预测准确率</strong></th>
<th style="text-align: center;"><strong>预测正确数</strong></th>
<th style="text-align: center;"><strong>预测总数</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">array_test1</td>
<td style="text-align: center;">311</td>
<td style="text-align: center;">54.55%</td>
<td style="text-align: center;">12</td>
<td style="text-align: center;">22</td>
</tr>
<tr class="even">
<td style="text-align: center;">array_test2</td>
<td style="text-align: center;">367</td>
<td style="text-align: center;">50.00%</td>
<td style="text-align: center;">13</td>
<td style="text-align: center;">26</td>
</tr>
<tr class="odd">
<td style="text-align: center;">basicopt1</td>
<td style="text-align: center;">798333</td>
<td style="text-align: center;">58.98%</td>
<td style="text-align: center;">91497</td>
<td style="text-align: center;">155139</td>
</tr>
<tr class="even">
<td style="text-align: center;">bulgarian</td>
<td style="text-align: center;">733162</td>
<td style="text-align: center;">50.64%</td>
<td style="text-align: center;">36204</td>
<td style="text-align: center;">71493</td>
</tr>
<tr class="odd">
<td style="text-align: center;">expr</td>
<td style="text-align: center;">716</td>
<td style="text-align: center;">37.84%</td>
<td style="text-align: center;">42</td>
<td style="text-align: center;">111</td>
</tr>
<tr class="even">
<td style="text-align: center;">gcd</td>
<td style="text-align: center;">695</td>
<td style="text-align: center;">62.50%</td>
<td style="text-align: center;">75</td>
<td style="text-align: center;">120</td>
</tr>
<tr class="odd">
<td style="text-align: center;">hanoi</td>
<td style="text-align: center;">372674</td>
<td style="text-align: center;">49.98%</td>
<td style="text-align: center;">8725</td>
<td style="text-align: center;">17457</td>
</tr>
<tr class="even">
<td style="text-align: center;">lvalue2</td>
<td style="text-align: center;">74</td>
<td style="text-align: center;">66.67%</td>
<td style="text-align: center;">4</td>
<td style="text-align: center;">6</td>
</tr>
<tr class="odd">
<td style="text-align: center;">magic</td>
<td style="text-align: center;">1015604</td>
<td style="text-align: center;">53.14%</td>
<td style="text-align: center;">36068</td>
<td style="text-align: center;">67869</td>
</tr>
<tr class="even">
<td style="text-align: center;">manyarguments</td>
<td style="text-align: center;">84</td>
<td style="text-align: center;">80.00%</td>
<td style="text-align: center;">8</td>
<td style="text-align: center;">10</td>
</tr>
<tr class="odd">
<td style="text-align: center;">multiarray</td>
<td style="text-align: center;">2893</td>
<td style="text-align: center;">18.52%</td>
<td style="text-align: center;">30</td>
<td style="text-align: center;">162</td>
</tr>
<tr class="even">
<td style="text-align: center;">naive</td>
<td style="text-align: center;">42</td>
<td style="text-align: center;">/</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
</tr>
<tr class="odd">
<td style="text-align: center;">pi</td>
<td style="text-align: center;">154175873</td>
<td style="text-align: center;">42.27%</td>
<td style="text-align: center;">16889646</td>
<td style="text-align: center;">39956380</td>
</tr>
<tr class="even">
<td style="text-align: center;">qsort</td>
<td style="text-align: center;">2610408</td>
<td style="text-align: center;">30.01%</td>
<td style="text-align: center;">60027</td>
<td style="text-align: center;">200045</td>
</tr>
<tr class="odd">
<td style="text-align: center;">queens</td>
<td style="text-align: center;">1098170</td>
<td style="text-align: center;">63.22%</td>
<td style="text-align: center;">48754</td>
<td style="text-align: center;">77116</td>
</tr>
<tr class="even">
<td style="text-align: center;">statement_test</td>
<td style="text-align: center;">1572</td>
<td style="text-align: center;">59.41%</td>
<td style="text-align: center;">120</td>
<td style="text-align: center;">202</td>
</tr>
<tr class="odd">
<td style="text-align: center;">superloop</td>
<td style="text-align: center;">642595</td>
<td style="text-align: center;">87.29%</td>
<td style="text-align: center;">379755</td>
<td style="text-align: center;">435027</td>
</tr>
<tr class="even">
<td style="text-align: center;">tak</td>
<td style="text-align: center;">3152987</td>
<td style="text-align: center;">75.00%</td>
<td style="text-align: center;">45479</td>
<td style="text-align: center;">60639</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>四位饱和计数器预测</strong>（平均预测准确率：<code>75.44%</code>）</li>
</ul>
<table>
<colgroup>
<col style="width: 27%">
<col style="width: 18%">
<col style="width: 18%">
<col style="width: 18%">
<col style="width: 16%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;"><strong>测试点</strong></th>
<th style="text-align: center;"><strong>时钟周期数</strong></th>
<th style="text-align: center;"><strong>预测准确率</strong></th>
<th style="text-align: center;"><strong>预测正确数</strong></th>
<th style="text-align: center;"><strong>预测总数</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">array_test1</td>
<td style="text-align: center;">299</td>
<td style="text-align: center;">54.55%</td>
<td style="text-align: center;">12</td>
<td style="text-align: center;">22</td>
</tr>
<tr class="even">
<td style="text-align: center;">array_test2</td>
<td style="text-align: center;">351</td>
<td style="text-align: center;">57.69%</td>
<td style="text-align: center;">15</td>
<td style="text-align: center;">26</td>
</tr>
<tr class="odd">
<td style="text-align: center;">basicopt1</td>
<td style="text-align: center;">664485</td>
<td style="text-align: center;">82.98%</td>
<td style="text-align: center;">128727</td>
<td style="text-align: center;">155139</td>
</tr>
<tr class="even">
<td style="text-align: center;">bulgarian</td>
<td style="text-align: center;">641530</td>
<td style="text-align: center;">93.77%</td>
<td style="text-align: center;">67041</td>
<td style="text-align: center;">71493</td>
</tr>
<tr class="odd">
<td style="text-align: center;">expr</td>
<td style="text-align: center;">614</td>
<td style="text-align: center;">83.78%</td>
<td style="text-align: center;">93</td>
<td style="text-align: center;">111</td>
</tr>
<tr class="even">
<td style="text-align: center;">gcd</td>
<td style="text-align: center;">629</td>
<td style="text-align: center;">68.33%</td>
<td style="text-align: center;">82</td>
<td style="text-align: center;">120</td>
</tr>
<tr class="odd">
<td style="text-align: center;">hanoi</td>
<td style="text-align: center;">351242</td>
<td style="text-align: center;">73.35%</td>
<td style="text-align: center;">12805</td>
<td style="text-align: center;">17457</td>
</tr>
<tr class="even">
<td style="text-align: center;">lvalue2</td>
<td style="text-align: center;">74</td>
<td style="text-align: center;">66.67%</td>
<td style="text-align: center;">4</td>
<td style="text-align: center;">6</td>
</tr>
<tr class="odd">
<td style="text-align: center;">magic</td>
<td style="text-align: center;">936056</td>
<td style="text-align: center;">81.00%</td>
<td style="text-align: center;">54971</td>
<td style="text-align: center;">67869</td>
</tr>
<tr class="even">
<td style="text-align: center;">manyarguments</td>
<td style="text-align: center;">88</td>
<td style="text-align: center;">60.00%</td>
<td style="text-align: center;">6</td>
<td style="text-align: center;">10</td>
</tr>
<tr class="odd">
<td style="text-align: center;">multiarray</td>
<td style="text-align: center;">2599</td>
<td style="text-align: center;">83.33%</td>
<td style="text-align: center;">135</td>
<td style="text-align: center;">162</td>
</tr>
<tr class="even">
<td style="text-align: center;">naive</td>
<td style="text-align: center;">42</td>
<td style="text-align: center;">/</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
</tr>
<tr class="odd">
<td style="text-align: center;">pi</td>
<td style="text-align: center;">117739039</td>
<td style="text-align: center;">83.64%</td>
<td style="text-align: center;">33418674</td>
<td style="text-align: center;">39956380</td>
</tr>
<tr class="even">
<td style="text-align: center;">qsort</td>
<td style="text-align: center;">2244586</td>
<td style="text-align: center;">89.07%</td>
<td style="text-align: center;">178189</td>
<td style="text-align: center;">200045</td>
</tr>
<tr class="odd">
<td style="text-align: center;">queens</td>
<td style="text-align: center;">1045312</td>
<td style="text-align: center;">75.99%</td>
<td style="text-align: center;">58599</td>
<td style="text-align: center;">77116</td>
</tr>
<tr class="even">
<td style="text-align: center;">statement_test</td>
<td style="text-align: center;">1460</td>
<td style="text-align: center;">61.39%</td>
<td style="text-align: center;">124</td>
<td style="text-align: center;">202</td>
</tr>
<tr class="odd">
<td style="text-align: center;">superloop</td>
<td style="text-align: center;">579101</td>
<td style="text-align: center;">92.28%</td>
<td style="text-align: center;">401458</td>
<td style="text-align: center;">435027</td>
</tr>
<tr class="even">
<td style="text-align: center;">tak</td>
<td style="text-align: center;">2971489</td>
<td style="text-align: center;">74.68%</td>
<td style="text-align: center;">45286</td>
<td style="text-align: center;">60639</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>二级自适应预测</strong>（平均预测准确率：<code>76.87%</code>）</li>
</ul>
<table>
<colgroup>
<col style="width: 27%">
<col style="width: 18%">
<col style="width: 18%">
<col style="width: 18%">
<col style="width: 16%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;"><strong>测试点</strong></th>
<th style="text-align: center;"><strong>时钟周期数</strong></th>
<th style="text-align: center;"><strong>预测准确率</strong></th>
<th style="text-align: center;"><strong>预测正确数</strong></th>
<th style="text-align: center;"><strong>预测总数</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">array_test1</td>
<td style="text-align: center;">299</td>
<td style="text-align: center;">54.55%</td>
<td style="text-align: center;">12</td>
<td style="text-align: center;">22</td>
</tr>
<tr class="even">
<td style="text-align: center;">array_test2</td>
<td style="text-align: center;">355</td>
<td style="text-align: center;">50.00%</td>
<td style="text-align: center;">13</td>
<td style="text-align: center;">26</td>
</tr>
<tr class="odd">
<td style="text-align: center;">basicopt1</td>
<td style="text-align: center;">613743</td>
<td style="text-align: center;">99.33%</td>
<td style="text-align: center;">154098</td>
<td style="text-align: center;">155139</td>
</tr>
<tr class="even">
<td style="text-align: center;">bulgarian</td>
<td style="text-align: center;">640080</td>
<td style="text-align: center;">94.79%</td>
<td style="text-align: center;">67766</td>
<td style="text-align: center;">71493</td>
</tr>
<tr class="odd">
<td style="text-align: center;">expr</td>
<td style="text-align: center;">660</td>
<td style="text-align: center;">63.06%</td>
<td style="text-align: center;">70</td>
<td style="text-align: center;">111</td>
</tr>
<tr class="even">
<td style="text-align: center;">gcd</td>
<td style="text-align: center;">645</td>
<td style="text-align: center;">61.67%</td>
<td style="text-align: center;">74</td>
<td style="text-align: center;">120</td>
</tr>
<tr class="odd">
<td style="text-align: center;">hanoi</td>
<td style="text-align: center;">342530</td>
<td style="text-align: center;">98.30%</td>
<td style="text-align: center;">17161</td>
<td style="text-align: center;">17457</td>
</tr>
<tr class="even">
<td style="text-align: center;">lvalue2</td>
<td style="text-align: center;">74</td>
<td style="text-align: center;">66.67%</td>
<td style="text-align: center;">4</td>
<td style="text-align: center;">6</td>
</tr>
<tr class="odd">
<td style="text-align: center;">magic</td>
<td style="text-align: center;">928756</td>
<td style="text-align: center;">86.37%</td>
<td style="text-align: center;">58621</td>
<td style="text-align: center;">67869</td>
</tr>
<tr class="even">
<td style="text-align: center;">manyarguments</td>
<td style="text-align: center;">84</td>
<td style="text-align: center;">80.00%</td>
<td style="text-align: center;">8</td>
<td style="text-align: center;">10</td>
</tr>
<tr class="odd">
<td style="text-align: center;">multiarray</td>
<td style="text-align: center;">2731</td>
<td style="text-align: center;">42.59%</td>
<td style="text-align: center;">69</td>
<td style="text-align: center;">162</td>
</tr>
<tr class="even">
<td style="text-align: center;">naive</td>
<td style="text-align: center;">42</td>
<td style="text-align: center;">/</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
</tr>
<tr class="odd">
<td style="text-align: center;">pi</td>
<td style="text-align: center;">117608981</td>
<td style="text-align: center;">83.80%</td>
<td style="text-align: center;">33483703</td>
<td style="text-align: center;">39956380</td>
</tr>
<tr class="even">
<td style="text-align: center;">qsort</td>
<td style="text-align: center;">2213370</td>
<td style="text-align: center;">96.88%</td>
<td style="text-align: center;">193797</td>
<td style="text-align: center;">200045</td>
</tr>
<tr class="odd">
<td style="text-align: center;">queens</td>
<td style="text-align: center;">1034246</td>
<td style="text-align: center;">83.16%</td>
<td style="text-align: center;">64132</td>
<td style="text-align: center;">77116</td>
</tr>
<tr class="even">
<td style="text-align: center;">statement_test</td>
<td style="text-align: center;">1460</td>
<td style="text-align: center;">61.39%</td>
<td style="text-align: center;">124</td>
<td style="text-align: center;">202</td>
</tr>
<tr class="odd">
<td style="text-align: center;">superloop</td>
<td style="text-align: center;">518797</td>
<td style="text-align: center;">99.21%</td>
<td style="text-align: center;">431610</td>
<td style="text-align: center;">435027</td>
</tr>
<tr class="even">
<td style="text-align: center;">tak</td>
<td style="text-align: center;">2959051</td>
<td style="text-align: center;">84.94%</td>
<td style="text-align: center;">51505</td>
<td style="text-align: center;">60639</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>混合分支预测</strong>（平均预测准确率：<code>80.94%</code>）</li>
</ul>
<table>
<colgroup>
<col style="width: 26%">
<col style="width: 18%">
<col style="width: 18%">
<col style="width: 18%">
<col style="width: 18%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;"><strong>测试点</strong></th>
<th style="text-align: center;"><strong>时钟周期数</strong></th>
<th style="text-align: center;"><strong>预测准确率</strong></th>
<th style="text-align: center;"><strong>预测正确数</strong></th>
<th style="text-align: center;"><strong>预测总数</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">array_test1</td>
<td style="text-align: center;">299</td>
<td style="text-align: center;">54.55%</td>
<td style="text-align: center;">12</td>
<td style="text-align: center;">22</td>
</tr>
<tr class="even">
<td style="text-align: center;">array_test2</td>
<td style="text-align: center;">351</td>
<td style="text-align: center;">57.69%</td>
<td style="text-align: center;">15</td>
<td style="text-align: center;">26</td>
</tr>
<tr class="odd">
<td style="text-align: center;">basicopt1</td>
<td style="text-align: center;">613647</td>
<td style="text-align: center;">99.36%</td>
<td style="text-align: center;">154146</td>
<td style="text-align: center;">155139</td>
</tr>
<tr class="even">
<td style="text-align: center;">bulgarian</td>
<td style="text-align: center;">639830</td>
<td style="text-align: center;">94.96%</td>
<td style="text-align: center;">67891</td>
<td style="text-align: center;">71493</td>
</tr>
<tr class="odd">
<td style="text-align: center;">expr</td>
<td style="text-align: center;">614</td>
<td style="text-align: center;">83.78%</td>
<td style="text-align: center;">93</td>
<td style="text-align: center;">111</td>
</tr>
<tr class="even">
<td style="text-align: center;">gcd</td>
<td style="text-align: center;">629</td>
<td style="text-align: center;">68.33%</td>
<td style="text-align: center;">82</td>
<td style="text-align: center;">120</td>
</tr>
<tr class="odd">
<td style="text-align: center;">hanoi</td>
<td style="text-align: center;">342524</td>
<td style="text-align: center;">98.32%</td>
<td style="text-align: center;">17164</td>
<td style="text-align: center;">17457</td>
</tr>
<tr class="even">
<td style="text-align: center;">lvalue2</td>
<td style="text-align: center;">74</td>
<td style="text-align: center;">66.67%</td>
<td style="text-align: center;">4</td>
<td style="text-align: center;">6</td>
</tr>
<tr class="odd">
<td style="text-align: center;">magic</td>
<td style="text-align: center;">928678</td>
<td style="text-align: center;">86.43%</td>
<td style="text-align: center;">58660</td>
<td style="text-align: center;">67869</td>
</tr>
<tr class="even">
<td style="text-align: center;">manyarguments</td>
<td style="text-align: center;">84</td>
<td style="text-align: center;">80.00%</td>
<td style="text-align: center;">8</td>
<td style="text-align: center;">10</td>
</tr>
<tr class="odd">
<td style="text-align: center;">multiarray</td>
<td style="text-align: center;">2615</td>
<td style="text-align: center;">78.40%</td>
<td style="text-align: center;">127</td>
<td style="text-align: center;">162</td>
</tr>
<tr class="even">
<td style="text-align: center;">naive</td>
<td style="text-align: center;">42</td>
<td style="text-align: center;">/</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
</tr>
<tr class="odd">
<td style="text-align: center;">pi</td>
<td style="text-align: center;">117608887</td>
<td style="text-align: center;">83.80%</td>
<td style="text-align: center;">33483750</td>
<td style="text-align: center;">39956380</td>
</tr>
<tr class="even">
<td style="text-align: center;">qsort</td>
<td style="text-align: center;">2213326</td>
<td style="text-align: center;">96.89%</td>
<td style="text-align: center;">193819</td>
<td style="text-align: center;">200045</td>
</tr>
<tr class="odd">
<td style="text-align: center;">queens</td>
<td style="text-align: center;">1034236</td>
<td style="text-align: center;">83.17%</td>
<td style="text-align: center;">64137</td>
<td style="text-align: center;">77116</td>
</tr>
<tr class="even">
<td style="text-align: center;">statement_test</td>
<td style="text-align: center;">1468</td>
<td style="text-align: center;">59.41%</td>
<td style="text-align: center;">120</td>
<td style="text-align: center;">202</td>
</tr>
<tr class="odd">
<td style="text-align: center;">superloop</td>
<td style="text-align: center;">518787</td>
<td style="text-align: center;">99.22%</td>
<td style="text-align: center;">431615</td>
<td style="text-align: center;">435027</td>
</tr>
<tr class="even">
<td style="text-align: center;">tak</td>
<td style="text-align: center;">2959047</td>
<td style="text-align: center;">84.94%</td>
<td style="text-align: center;">51507</td>
<td style="text-align: center;">60639</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>横向对比</strong></li>
</ul>
<table style="width:100%;">
<colgroup>
<col style="width: 20%">
<col style="width: 13%">
<col style="width: 18%">
<col style="width: 16%">
<col style="width: 16%">
<col style="width: 13%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;"><strong>测试点</strong></th>
<th style="text-align: center;"><strong>预测总数</strong></th>
<th style="text-align: center;"><strong>静态预测（不跳转）</strong></th>
<th style="text-align: center;"><strong>四位饱和计数器</strong></th>
<th style="text-align: center;"><strong>二级自适应预测</strong></th>
<th style="text-align: center;"><strong>混合预测</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">array_test1</td>
<td style="text-align: center;">22</td>
<td style="text-align: center;"><strong><font color="#2aa4db">54.55%</font></strong></td>
<td style="text-align: center;"><strong><font color="#2aa4db">54.55%</font></strong></td>
<td style="text-align: center;"><strong><font color="#2aa4db">54.55%</font></strong></td>
<td style="text-align: center;"><strong><font color="#2aa4db">54.55%</font></strong></td>
</tr>
<tr class="even">
<td style="text-align: center;">array_test2</td>
<td style="text-align: center;">26</td>
<td style="text-align: center;">50.00%</td>
<td style="text-align: center;"><strong><font color="#2aa4db">57.69%</font></strong></td>
<td style="text-align: center;">50.00%</td>
<td style="text-align: center;"><strong><font color="#2aa4db">57.69%</font></strong></td>
</tr>
<tr class="odd">
<td style="text-align: center;">basicopt1</td>
<td style="text-align: center;">155139</td>
<td style="text-align: center;">58.98%</td>
<td style="text-align: center;">82.98%</td>
<td style="text-align: center;">99.33%</td>
<td style="text-align: center;"><strong><font color="#2aa4db">99.36%</font></strong></td>
</tr>
<tr class="even">
<td style="text-align: center;">bulgarian</td>
<td style="text-align: center;">71493</td>
<td style="text-align: center;">50.64%</td>
<td style="text-align: center;">93.77%</td>
<td style="text-align: center;">94.79%</td>
<td style="text-align: center;"><strong><font color="#2aa4db">94.96%</font></strong></td>
</tr>
<tr class="odd">
<td style="text-align: center;">expr</td>
<td style="text-align: center;">111</td>
<td style="text-align: center;">37.84%</td>
<td style="text-align: center;"><strong><font color="#2aa4db">83.78%</font></strong></td>
<td style="text-align: center;">63.06%</td>
<td style="text-align: center;"><strong><font color="#2aa4db">83.78%</font></strong></td>
</tr>
<tr class="even">
<td style="text-align: center;">gcd</td>
<td style="text-align: center;">120</td>
<td style="text-align: center;">62.50%</td>
<td style="text-align: center;"><strong><font color="#2aa4db">68.33%</font></strong></td>
<td style="text-align: center;">61.67%</td>
<td style="text-align: center;"><strong><font color="#2aa4db">68.33%</font></strong></td>
</tr>
<tr class="odd">
<td style="text-align: center;">hanoi</td>
<td style="text-align: center;">17457</td>
<td style="text-align: center;">49.98%</td>
<td style="text-align: center;">73.35%</td>
<td style="text-align: center;">98.30%</td>
<td style="text-align: center;"><strong><font color="#2aa4db">98.32%</font></strong></td>
</tr>
<tr class="even">
<td style="text-align: center;">lvalue2</td>
<td style="text-align: center;">6</td>
<td style="text-align: center;"><strong><font color="#2aa4db">66.67%</font></strong></td>
<td style="text-align: center;"><strong><font color="#2aa4db">66.67%</font></strong></td>
<td style="text-align: center;"><strong><font color="#2aa4db">66.67%</font></strong></td>
<td style="text-align: center;"><strong><font color="#2aa4db">66.67%</font></strong></td>
</tr>
<tr class="odd">
<td style="text-align: center;">magic</td>
<td style="text-align: center;">67869</td>
<td style="text-align: center;">53.14%</td>
<td style="text-align: center;">81.00%</td>
<td style="text-align: center;">86.37%</td>
<td style="text-align: center;"><strong><font color="#2aa4db">86.43%</font></strong></td>
</tr>
<tr class="even">
<td style="text-align: center;">manyarguments</td>
<td style="text-align: center;">10</td>
<td style="text-align: center;"><strong><font color="#2aa4db">80.00%</font></strong></td>
<td style="text-align: center;">60.00%</td>
<td style="text-align: center;"><strong><font color="#2aa4db">80.00%</font></strong></td>
<td style="text-align: center;"><strong><font color="#2aa4db">80.00%</font></strong></td>
</tr>
<tr class="odd">
<td style="text-align: center;">multiarray</td>
<td style="text-align: center;">162</td>
<td style="text-align: center;">18.52%</td>
<td style="text-align: center;"><strong><font color="#2aa4db">83.33%</font></strong></td>
<td style="text-align: center;">42.59%</td>
<td style="text-align: center;">78.40%</td>
</tr>
<tr class="even">
<td style="text-align: center;">naive</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">/</td>
<td style="text-align: center;">/</td>
<td style="text-align: center;">/</td>
<td style="text-align: center;">/</td>
</tr>
<tr class="odd">
<td style="text-align: center;">pi</td>
<td style="text-align: center;">39956380</td>
<td style="text-align: center;">42.27%</td>
<td style="text-align: center;">83.64%</td>
<td style="text-align: center;">83.80%</td>
<td style="text-align: center;"><strong><font color="#2aa4db">83.80%</font></strong></td>
</tr>
<tr class="even">
<td style="text-align: center;">qsort</td>
<td style="text-align: center;">200045</td>
<td style="text-align: center;">30.01%</td>
<td style="text-align: center;">89.07%</td>
<td style="text-align: center;">96.88%</td>
<td style="text-align: center;"><strong><font color="#2aa4db">96.89%</font></strong></td>
</tr>
<tr class="odd">
<td style="text-align: center;">queens</td>
<td style="text-align: center;">77116</td>
<td style="text-align: center;">63.22%</td>
<td style="text-align: center;">75.99%</td>
<td style="text-align: center;">83.16%</td>
<td style="text-align: center;"><strong><font color="#2aa4db">83.17%</font></strong></td>
</tr>
<tr class="even">
<td style="text-align: center;">statement_test</td>
<td style="text-align: center;">202</td>
<td style="text-align: center;">59.41%</td>
<td style="text-align: center;"><strong><font color="#2aa4db">61.39%</font></strong></td>
<td style="text-align: center;"><strong><font color="#2aa4db">61.39%</font></strong></td>
<td style="text-align: center;">59.41%</td>
</tr>
<tr class="odd">
<td style="text-align: center;">superloop</td>
<td style="text-align: center;">435027</td>
<td style="text-align: center;">87.29%</td>
<td style="text-align: center;">92.28%</td>
<td style="text-align: center;">99.21%</td>
<td style="text-align: center;"><strong><font color="#2aa4db">99.22%</font></strong></td>
</tr>
<tr class="even">
<td style="text-align: center;">tak</td>
<td style="text-align: center;">60639</td>
<td style="text-align: center;">75.00%</td>
<td style="text-align: center;">74.68%</td>
<td style="text-align: center;">84.94%</td>
<td style="text-align: center;"><strong><font color="#2aa4db">84.94%</font></strong></td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>CS学习之路</category>
      </categories>
  </entry>
  <entry>
    <title>如何在Hexo博客中插入图片</title>
    <url>/2022/04/23/hexo-insert-pictures/</url>
    <content><![CDATA[<blockquote>
<p>写在前面：本系列是笔者在搭建博客过程中遇到了问题，在成功解决后的一些经验分享</p>
</blockquote>
<p>本文详细介绍了如何在博客中插入图片，参考了网上教程。</p>
<span id="more"></span>
<h2 id="第一步安装插件">第一步：安装插件</h2>
<p>在博客根目录（笔者的是 <code>D:\Blog</code> ）打开
<code>git-bash</code> ，执行以下指令 <figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">npm install hexo-asset-<span class="built_in">image</span> --<span class="built_in">save</span></span><br></pre></td></tr></table></figure></p>
<h2 id="第二步修改配置文件">第二步：修改配置文件</h2>
<p>在博客配置文件 <code>_config.yml</code> 中找到
<code>post_asset_folder</code> ，将选项由 <code>false</code> 更改为
<code>true</code></p>
<h2 id="第三步修改插件js文件内容">第三步：修改插件js文件内容</h2>
<p>打开 <code>\node_modules\hexo-asset-image\index.js</code>
，将全部内容更改为以下代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"><span class="keyword">var</span> cheerio = <span class="built_in">require</span>(<span class="string">'cheerio'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getPosition</span>(<span class="params">str, m, i</span>) {</span><br><span class="line">  <span class="keyword">return</span> str.<span class="title function_">split</span>(m, i).<span class="title function_">join</span>(m).<span class="property">length</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> version = <span class="title class_">String</span>(hexo.<span class="property">version</span>).<span class="title function_">split</span>(<span class="string">'.'</span>);</span><br><span class="line">hexo.<span class="property">extend</span>.<span class="property">filter</span>.<span class="title function_">register</span>(<span class="string">'after_post_render'</span>, <span class="keyword">function</span>(<span class="params">data</span>){</span><br><span class="line">  <span class="keyword">var</span> config = hexo.<span class="property">config</span>;</span><br><span class="line">  <span class="keyword">if</span>(config.<span class="property">post_asset_folder</span>){</span><br><span class="line">        <span class="keyword">var</span> link = data.<span class="property">permalink</span>;</span><br><span class="line">    <span class="keyword">if</span>(version.<span class="property">length</span> &gt; <span class="number">0</span> &amp;&amp; <span class="title class_">Number</span>(version[<span class="number">0</span>]) == <span class="number">3</span>)</span><br><span class="line">       <span class="keyword">var</span> beginPos = <span class="title function_">getPosition</span>(link, <span class="string">'/'</span>, <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">       <span class="keyword">var</span> beginPos = <span class="title function_">getPosition</span>(link, <span class="string">'/'</span>, <span class="number">3</span>) + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// In hexo 3.1.1, the permalink of "about" page is like ".../about/index.html".</span></span><br><span class="line">    <span class="keyword">var</span> endPos = link.<span class="title function_">lastIndexOf</span>(<span class="string">'/'</span>) + <span class="number">1</span>;</span><br><span class="line">    link = link.<span class="title function_">substring</span>(beginPos, endPos);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> toprocess = [<span class="string">'excerpt'</span>, <span class="string">'more'</span>, <span class="string">'content'</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; toprocess.<span class="property">length</span>; i++){</span><br><span class="line">      <span class="keyword">var</span> key = toprocess[i];</span><br><span class="line"> </span><br><span class="line">      <span class="keyword">var</span> $ = cheerio.<span class="title function_">load</span>(data[key], {</span><br><span class="line">        <span class="attr">ignoreWhitespace</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">xmlMode</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">lowerCaseTags</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">decodeEntities</span>: <span class="literal">false</span></span><br><span class="line">      });</span><br><span class="line"></span><br><span class="line">      $(<span class="string">'img'</span>).<span class="title function_">each</span>(<span class="keyword">function</span>(<span class="params"></span>){</span><br><span class="line">        <span class="keyword">if</span> ($(<span class="variable language_">this</span>).<span class="title function_">attr</span>(<span class="string">'src'</span>)){</span><br><span class="line">            <span class="comment">// For windows style path, we replace '\' to '/'.</span></span><br><span class="line">            <span class="keyword">var</span> src = $(<span class="variable language_">this</span>).<span class="title function_">attr</span>(<span class="string">'src'</span>).<span class="title function_">replace</span>(<span class="string">'\\'</span>, <span class="string">'/'</span>);</span><br><span class="line">            <span class="keyword">if</span>(!<span class="regexp">/http[s]*.*|\/\/.*/</span>.<span class="title function_">test</span>(src) &amp;&amp;</span><br><span class="line">               !<span class="regexp">/^\s*\//</span>.<span class="title function_">test</span>(src)) {</span><br><span class="line">              <span class="comment">// For "about" page, the first part of "src" can't be removed.</span></span><br><span class="line">              <span class="comment">// In addition, to support multi-level local directory.</span></span><br><span class="line">              <span class="keyword">var</span> linkArray = link.<span class="title function_">split</span>(<span class="string">'/'</span>).<span class="title function_">filter</span>(<span class="keyword">function</span>(<span class="params">elem</span>){</span><br><span class="line">                <span class="keyword">return</span> elem != <span class="string">''</span>;</span><br><span class="line">              });</span><br><span class="line">              <span class="keyword">var</span> srcArray = src.<span class="title function_">split</span>(<span class="string">'/'</span>).<span class="title function_">filter</span>(<span class="keyword">function</span>(<span class="params">elem</span>){</span><br><span class="line">                <span class="keyword">return</span> elem != <span class="string">''</span> &amp;&amp; elem != <span class="string">'.'</span>;</span><br><span class="line">              });</span><br><span class="line">              <span class="keyword">if</span>(srcArray.<span class="property">length</span> &gt; <span class="number">1</span>)</span><br><span class="line">                srcArray.<span class="title function_">shift</span>();</span><br><span class="line">              src = srcArray.<span class="title function_">join</span>(<span class="string">'/'</span>);</span><br><span class="line">              $(<span class="variable language_">this</span>).<span class="title function_">attr</span>(<span class="string">'src'</span>, config.<span class="property">root</span> + link + src);</span><br><span class="line">              <span class="variable language_">console</span>.<span class="property">info</span>&amp;&amp;<span class="variable language_">console</span>.<span class="title function_">info</span>(<span class="string">"update link as:--&gt;"</span>+config.<span class="property">root</span> + link + src);</span><br><span class="line">            }</span><br><span class="line">        }<span class="keyword">else</span>{</span><br><span class="line">            <span class="variable language_">console</span>.<span class="property">info</span>&amp;&amp;<span class="variable language_">console</span>.<span class="title function_">info</span>(<span class="string">"no src attr, skipped..."</span>);</span><br><span class="line">            <span class="variable language_">console</span>.<span class="property">info</span>&amp;&amp;<span class="variable language_">console</span>.<span class="title function_">info</span>($(<span class="variable language_">this</span>));</span><br><span class="line">        }</span><br><span class="line">      });</span><br><span class="line">      data[key] = $.<span class="title function_">html</span>();</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">});</span><br></pre></td></tr></table></figure>
<p>（代码来源互联网，笔者也暂时不能理解其中内容，侵删）</p>
<h2 id="第四步插入图片">第四步：插入图片</h2>
<p>在输入指令 <code>hexo new filename</code>
新建博客之后，<code>\source\_posts</code> 文件夹中就会生成
<code>filename.md</code> 和 <code>filename</code>
文件夹，将要插入的图片复制到 <code>filename</code> 文件夹中，在
<code>filename.md</code> 中按照 <code>Markdown</code> 语法引用图片。</p>
<p>例如图片名称为 <code>blackhole.png</code> ，那么就写</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">![<span class="string">在图片加载不出时的替代文字</span>](<span class="link">blackhole.png "图片的脚注内容"</span>)</span><br></pre></td></tr></table></figure>
<p>即可成功插入图片，效果如下：</p>
<ul>
<li><p>成功插入图片示例： <img src="/2022/04/23/hexo-insert-pictures/blackhole.png" title="黑洞" alt="看到这句话说明图片加载失败了"></p></li>
<li><p>未成功插入图片示例： <img src="/2022/04/23/hexo-insert-pictures/1.png" title="黑洞" alt="看到这句话说明图片加载失败了"></p></li>
</ul>
<hr>
<p>看到这，相信读者你应该已经能在文章中成功插入图片了，博客的内容也将会变得更加丰富多彩。</p>
<p>希望这篇文章能对你有所帮助！</p>
]]></content>
      <categories>
        <category>Hexo经验总结</category>
      </categories>
  </entry>
  <entry>
    <title>STLite</title>
    <url>/2022/05/04/STLite/</url>
    <content><![CDATA[<p>本文是《数据结构（荣誉）》课程大作业的代码存档，内容是模拟实现了STL中部分数据结构以及一些拓展数据结构的功能。</p>
<span id="more"></span>
<hr>
<h1 id="vector">vector</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Finished by MeteorVanish on 2022.3.9</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SJTU_VECTOR_HPP</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SJTU_VECTOR_HPP</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;exceptions.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstddef&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INITSIZE 100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> sjtu</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">vector</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        T *arr;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> nowsize, maxsize;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">deletespace</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nowsize; ++i)</span><br><span class="line">                arr[i].~<span class="built_in">T</span>();</span><br><span class="line">            <span class="built_in">free</span>(arr);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">doublespace</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            maxsize *= <span class="number">2</span>;</span><br><span class="line">            T *temp = (T *)<span class="built_in">malloc</span>(maxsize * <span class="built_in">sizeof</span>(T));</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> i = <span class="number">0</span>; i &lt; nowsize; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">new</span>(temp + i) <span class="built_in">T</span>(arr[i]);</span><br><span class="line">                arr[i].~<span class="built_in">T</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">free</span>(arr);</span><br><span class="line">            arr = temp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">const_iterator</span>;</span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">iterator</span></span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line">            vector&lt;T&gt; *ptr;</span><br><span class="line">            <span class="type">int</span> index;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            <span class="built_in">iterator</span>() = <span class="keyword">default</span>;</span><br><span class="line">            <span class="built_in">iterator</span>(<span class="type">const</span> iterator&amp; other) = <span class="keyword">default</span>;</span><br><span class="line">            <span class="built_in">iterator</span>(vector&lt;T&gt; *_ptr, <span class="type">int</span> _index) :<span class="built_in">ptr</span>(_ptr), <span class="built_in">index</span>(_index) &#123;&#125;</span><br><span class="line"></span><br><span class="line">            iterator <span class="keyword">operator</span>+(<span class="type">const</span> <span class="type">int</span> &amp;n) <span class="type">const</span> &#123;<span class="keyword">return</span> <span class="built_in">iterator</span>(ptr, index + n);&#125;</span><br><span class="line">            iterator <span class="keyword">operator</span>-(<span class="type">const</span> <span class="type">int</span> &amp;n) <span class="type">const</span> &#123;<span class="keyword">return</span> <span class="built_in">iterator</span>(ptr, index - n);&#125;</span><br><span class="line">            <span class="type">int</span> <span class="keyword">operator</span>-(<span class="type">const</span> iterator &amp;rhs) <span class="type">const</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(ptr != rhs.ptr)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="built_in">invalid_iterator</span>();</span><br><span class="line">                <span class="keyword">return</span> index - rhs.index;</span><br><span class="line">            &#125;</span><br><span class="line">            iterator&amp; <span class="keyword">operator</span>+=(<span class="type">const</span> <span class="type">int</span> &amp;n)</span><br><span class="line">            &#123;</span><br><span class="line">                index += n;</span><br><span class="line">                <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            iterator&amp; <span class="keyword">operator</span>-=(<span class="type">const</span> <span class="type">int</span> &amp;n)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(index-n &lt; <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="built_in">runtime_error</span>();</span><br><span class="line">                index -= n;</span><br><span class="line">                <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            iterator <span class="keyword">operator</span>++(<span class="type">int</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                iterator temp = *<span class="keyword">this</span>;</span><br><span class="line">                ++index;</span><br><span class="line">                <span class="keyword">return</span> temp;</span><br><span class="line">            &#125;</span><br><span class="line">            iterator&amp; <span class="keyword">operator</span>++()</span><br><span class="line">            &#123;</span><br><span class="line">                ++index;</span><br><span class="line">                <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            iterator <span class="keyword">operator</span>--(<span class="type">int</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(!index)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="built_in">runtime_error</span>();</span><br><span class="line">                iterator temp = *<span class="keyword">this</span>;</span><br><span class="line">                --index;</span><br><span class="line">                <span class="keyword">return</span> temp;</span><br><span class="line">            &#125;</span><br><span class="line">            iterator&amp; <span class="keyword">operator</span>--()</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(!index)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="built_in">runtime_error</span>();</span><br><span class="line">                --index;</span><br><span class="line">                <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            T&amp; <span class="keyword">operator</span>*() <span class="type">const</span> &#123;<span class="keyword">return</span> ptr-&gt;arr[index];&#125;</span><br><span class="line">            <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> iterator &amp;rhs) <span class="type">const</span> &#123;<span class="keyword">return</span> ptr == rhs.ptr &amp;&amp; index == rhs.index;&#125;</span><br><span class="line">            <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> const_iterator &amp;rhs) <span class="type">const</span> &#123;<span class="keyword">return</span> ptr == rhs.ptr &amp;&amp; index == rhs.index;&#125;</span><br><span class="line">            <span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> iterator &amp;rhs) <span class="type">const</span> &#123;<span class="keyword">return</span> !(*<span class="keyword">this</span> == rhs);&#125;</span><br><span class="line">            <span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> const_iterator &amp;rhs) <span class="type">const</span> &#123;<span class="keyword">return</span> !(*<span class="keyword">this</span> == rhs);&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">const_iterator</span></span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line">            <span class="type">const</span> vector *ptr;</span><br><span class="line">            <span class="type">int</span> index;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            <span class="built_in">const_iterator</span>(<span class="type">const</span> vector *p, <span class="type">int</span> idx) :<span class="built_in">ptr</span>(p),<span class="built_in">index</span>(idx) &#123;&#125;</span><br><span class="line">            const_iterator <span class="keyword">operator</span>+(<span class="type">const</span> <span class="type">int</span> &amp;n) <span class="type">const</span> &#123;<span class="keyword">return</span> <span class="built_in">const_iterator</span>(ptr, index + n);&#125;</span><br><span class="line">            const_iterator <span class="keyword">operator</span>-(<span class="type">const</span> <span class="type">int</span> &amp;n) <span class="type">const</span> &#123;<span class="keyword">return</span> <span class="built_in">const_iterator</span>(ptr, index - n);&#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="keyword">operator</span>-(<span class="type">const</span> iterator &amp;rhs) <span class="type">const</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(ptr != rhs.ptr)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="built_in">invalid_iterator</span>();</span><br><span class="line">                <span class="type">int</span> temp = index - rhs.index;</span><br><span class="line">                <span class="keyword">return</span> temp &gt;= <span class="number">0</span> ? temp : -temp;</span><br><span class="line">            &#125;</span><br><span class="line">            const_iterator&amp; <span class="keyword">operator</span>+=(<span class="type">const</span> <span class="type">int</span> &amp;n)</span><br><span class="line">            &#123;</span><br><span class="line">                index += n;</span><br><span class="line">                <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            const_iterator&amp; <span class="keyword">operator</span>-=(<span class="type">const</span> <span class="type">int</span> &amp;n)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(index-n &lt; <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="built_in">runtime_error</span>();</span><br><span class="line">                index -= n;</span><br><span class="line">                <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            const_iterator <span class="keyword">operator</span>++(<span class="type">int</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                const_iterator temp = *<span class="keyword">this</span>;</span><br><span class="line">                ++index;</span><br><span class="line">                <span class="keyword">return</span> temp;</span><br><span class="line">            &#125;</span><br><span class="line">            const_iterator&amp; <span class="keyword">operator</span>++()</span><br><span class="line">            &#123;</span><br><span class="line">                ++index;</span><br><span class="line">                <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            const_iterator <span class="keyword">operator</span>--(<span class="type">int</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(!index)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="built_in">runtime_error</span>();</span><br><span class="line">                const_iterator temp = *<span class="keyword">this</span>;</span><br><span class="line">                --index;</span><br><span class="line">                <span class="keyword">return</span> temp;</span><br><span class="line">            &#125;</span><br><span class="line">            const_iterator&amp; <span class="keyword">operator</span>--()</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(!index)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="built_in">runtime_error</span>();</span><br><span class="line">                --index;</span><br><span class="line">                <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            T&amp; <span class="keyword">operator</span>*() <span class="type">const</span> &#123;<span class="keyword">return</span> ptr-&gt;arr[index];&#125;</span><br><span class="line">            <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> iterator &amp;rhs) <span class="type">const</span> &#123;<span class="keyword">return</span> ptr == rhs.ptr &amp;&amp; index == rhs.index;&#125;</span><br><span class="line">            <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> const_iterator &amp;rhs) <span class="type">const</span> &#123;<span class="keyword">return</span> ptr == rhs.ptr &amp;&amp; index == rhs.index;&#125;</span><br><span class="line">            <span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> iterator &amp;rhs) <span class="type">const</span> &#123;<span class="keyword">return</span> !(*<span class="keyword">this</span> == rhs);&#125;</span><br><span class="line">            <span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> const_iterator &amp;rhs) <span class="type">const</span> &#123;<span class="keyword">return</span> !(*<span class="keyword">this</span> == rhs);&#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>() :<span class="built_in">nowsize</span>(<span class="number">0</span>), <span class="built_in">maxsize</span>(INITSIZE) &#123;arr = (T *)<span class="built_in">malloc</span>(maxsize * <span class="built_in">sizeof</span>(T));&#125;</span><br><span class="line">        <span class="built_in">vector</span>(<span class="type">const</span> vector &amp;other) :<span class="built_in">nowsize</span>(other.nowsize),<span class="built_in">maxsize</span>(other.maxsize)</span><br><span class="line">        &#123;</span><br><span class="line">            arr = (T *)<span class="built_in">malloc</span>(maxsize * <span class="built_in">sizeof</span>(T));</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> i = <span class="number">0</span>; i &lt; nowsize; ++i)</span><br><span class="line">                <span class="keyword">new</span>(arr + i) <span class="built_in">T</span>(other.arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        ~<span class="built_in">vector</span>() &#123;<span class="built_in">deletespace</span>();&#125;</span><br><span class="line"></span><br><span class="line">        vector &amp;<span class="keyword">operator</span>=(<span class="type">const</span> vector &amp;other)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span> == &amp;other) <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">            <span class="built_in">deletespace</span>();</span><br><span class="line">            nowsize = other.nowsize;</span><br><span class="line">            maxsize = other.maxsize;</span><br><span class="line">            arr = (T *)<span class="built_in">malloc</span>(maxsize * <span class="built_in">sizeof</span>(T));</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nowsize; ++i)</span><br><span class="line">                <span class="keyword">new</span>(arr+i) <span class="built_in">T</span>(other.arr[i]);</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">T &amp; <span class="title">at</span><span class="params">(<span class="type">const</span> <span class="type">size_t</span> &amp;pos)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(pos &lt; <span class="number">0</span> || pos &gt;= nowsize)</span><br><span class="line">                <span class="keyword">throw</span> <span class="built_in">index_out_of_bound</span>();</span><br><span class="line">            <span class="keyword">return</span> arr[pos];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">const</span> T &amp; <span class="title">at</span><span class="params">(<span class="type">const</span> <span class="type">size_t</span> &amp;pos)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(pos &lt; <span class="number">0</span> || pos &gt;= nowsize)</span><br><span class="line">                <span class="keyword">throw</span> <span class="built_in">index_out_of_bound</span>();</span><br><span class="line">            <span class="keyword">return</span> arr[pos];</span><br><span class="line">        &#125;</span><br><span class="line">        T &amp; <span class="keyword">operator</span>[](<span class="type">const</span> <span class="type">size_t</span> &amp;pos)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(pos &lt; <span class="number">0</span> || pos &gt;= nowsize)</span><br><span class="line">                <span class="keyword">throw</span> <span class="built_in">index_out_of_bound</span>();</span><br><span class="line">            <span class="keyword">return</span> arr[pos];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">const</span> T &amp; <span class="keyword">operator</span>[](<span class="type">const</span> <span class="type">size_t</span> &amp;pos) <span class="type">const</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(pos &lt; <span class="number">0</span> || pos &gt;= nowsize)</span><br><span class="line">                <span class="keyword">throw</span> <span class="built_in">index_out_of_bound</span>();</span><br><span class="line">            <span class="keyword">return</span> arr[pos];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">const</span> T &amp; <span class="title">front</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(!nowsize)</span><br><span class="line">                <span class="keyword">throw</span> <span class="built_in">container_is_empty</span>();</span><br><span class="line">            <span class="keyword">return</span> arr[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">const</span> T &amp; <span class="title">back</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(!nowsize)</span><br><span class="line">                <span class="keyword">throw</span> <span class="built_in">container_is_empty</span>();</span><br><span class="line">            <span class="keyword">return</span> arr[nowsize<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> <span class="built_in">iterator</span>(<span class="keyword">this</span>, <span class="number">0</span>);&#125;</span><br><span class="line">        <span class="function">const_iterator <span class="title">cbegin</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> <span class="built_in">const_iterator</span>(<span class="keyword">this</span>, <span class="number">0</span>);&#125;</span><br><span class="line">        <span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> <span class="built_in">iterator</span>(<span class="keyword">this</span>, nowsize);&#125;</span><br><span class="line">        <span class="function">const_iterator <span class="title">cend</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> <span class="built_in">const_iterator</span>(<span class="keyword">this</span>, nowsize);&#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> !nowsize;&#125;</span><br><span class="line">        <span class="function"><span class="type">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> nowsize;&#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nowsize; ++i)</span><br><span class="line">                arr[i].~<span class="built_in">T</span>();</span><br><span class="line">            nowsize = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">iterator <span class="title">insert</span><span class="params">(iterator pos, <span class="type">const</span> T &amp;value)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(nowsize == maxsize)</span><br><span class="line">                <span class="built_in">doublespace</span>();</span><br><span class="line">            <span class="keyword">new</span>(arr + nowsize) <span class="built_in">T</span>(arr[nowsize<span class="number">-1</span>]);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> i = nowsize - <span class="number">1</span>; i &gt; pos - <span class="built_in">begin</span>(); --i)</span><br><span class="line">                arr[i] = arr[i - <span class="number">1</span>];</span><br><span class="line">            arr[pos - <span class="built_in">begin</span>()] = value;</span><br><span class="line">            ++nowsize;</span><br><span class="line">            <span class="keyword">return</span> pos;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">iterator <span class="title">insert</span><span class="params">(<span class="type">const</span> <span class="type">size_t</span> &amp;ind, <span class="type">const</span> T &amp;value)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(ind &gt; nowsize)</span><br><span class="line">                <span class="keyword">throw</span> <span class="built_in">index_out_of_bound</span>();</span><br><span class="line">            <span class="keyword">if</span>(nowsize == maxsize)</span><br><span class="line">                <span class="built_in">doublespace</span>();</span><br><span class="line">            <span class="keyword">new</span>(arr + nowsize) <span class="built_in">T</span>(arr[nowsize - <span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> i = nowsize<span class="number">-1</span>; i &gt; ind; --i)</span><br><span class="line">                arr[i] = arr[i - <span class="number">1</span>];</span><br><span class="line">            arr[ind] = value;</span><br><span class="line">            ++nowsize;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">iterator</span>(<span class="keyword">this</span>, ind);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">iterator <span class="title">erase</span><span class="params">(iterator pos)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> i = pos - <span class="built_in">begin</span>(); i &lt; nowsize<span class="number">-1</span>; ++i)</span><br><span class="line">                arr[i] = arr[i + <span class="number">1</span>];</span><br><span class="line">            arr[--nowsize].~<span class="built_in">T</span>();</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">iterator</span>(<span class="keyword">this</span>, pos - <span class="built_in">begin</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">iterator <span class="title">erase</span><span class="params">(<span class="type">const</span> <span class="type">size_t</span> &amp;ind)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(ind &gt;= nowsize)</span><br><span class="line">                <span class="keyword">throw</span> <span class="built_in">index_out_of_bound</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> i = ind; i &lt; nowsize - <span class="number">1</span>; ++i)</span><br><span class="line">                arr[i] = arr[i + <span class="number">1</span>];</span><br><span class="line">            arr[--nowsize].~<span class="built_in">T</span>();</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">iterator</span>(<span class="keyword">this</span>, ind);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(<span class="type">const</span> T &amp;value)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(nowsize == maxsize)</span><br><span class="line">                <span class="built_in">doublespace</span>();</span><br><span class="line">            <span class="keyword">new</span>(arr + nowsize++) <span class="built_in">T</span>(value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">pop_back</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(!nowsize)</span><br><span class="line">                <span class="keyword">throw</span> <span class="built_in">container_is_empty</span>();</span><br><span class="line">            arr[--nowsize].~<span class="built_in">T</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125; <span class="comment">// namespace sjtu</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//SJTU_VECTOR_HPP</span></span></span><br></pre></td></tr></table></figure>
<hr>
<h1 id="list">list</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Finished by MeteorVanish on 2022.3.27</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SJTU_LIST_HPP</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SJTU_LIST_HPP</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;exceptions.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;algorithm.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstddef&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> sjtu</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">list</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">node</span></span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            T *data;</span><br><span class="line">            node *prev, *next;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">explicit</span> <span class="title">node</span><span class="params">(node *_prev = <span class="literal">nullptr</span>, node *_next = <span class="literal">nullptr</span>)</span></span></span><br><span class="line"><span class="function">                    :data(nullptr), prev(_prev), next(_next) &#123;</span>&#125;;</span><br><span class="line">            <span class="function"><span class="keyword">explicit</span> <span class="title">node</span><span class="params">(<span class="type">const</span> T &amp;_data, node *_prev = <span class="literal">nullptr</span>, node *_next = <span class="literal">nullptr</span>)</span></span></span><br><span class="line"><span class="function">                    :data(new T(_data)), prev(_prev), next(_next) &#123;</span>&#125;;</span><br><span class="line">            ~<span class="built_in">node</span>() &#123;<span class="keyword">if</span>(data) <span class="keyword">delete</span> data;&#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">        node *head, *tail;</span><br><span class="line">        <span class="type">size_t</span> len;</span><br><span class="line"></span><br><span class="line">        <span class="function">node *<span class="title">insert</span><span class="params">(node *pos, node *cur)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(pos == head)</span><br><span class="line">                <span class="keyword">throw</span> <span class="built_in">runtime_error</span>();</span><br><span class="line">            cur-&gt;prev = pos-&gt;prev;</span><br><span class="line">            cur-&gt;next = pos;</span><br><span class="line">            cur-&gt;prev-&gt;next = cur;</span><br><span class="line">            cur-&gt;next-&gt;prev = cur;</span><br><span class="line">            ++len;</span><br><span class="line">            <span class="keyword">return</span> cur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">node *<span class="title">erase</span><span class="params">(node *pos)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(pos == head || pos == tail)</span><br><span class="line">                <span class="keyword">throw</span> <span class="built_in">runtime_error</span>();</span><br><span class="line">            pos-&gt;prev-&gt;next = pos-&gt;next;</span><br><span class="line">            pos-&gt;next-&gt;prev = pos-&gt;prev;</span><br><span class="line">            --len;</span><br><span class="line">            <span class="keyword">return</span> pos;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">const_iterator</span>;</span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">iterator</span></span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line">            <span class="type">const</span> list&lt;T&gt; *plist;</span><br><span class="line">            node *pos;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            <span class="function"><span class="keyword">explicit</span> <span class="title">iterator</span><span class="params">(<span class="type">const</span> list&lt;T&gt; *_plist = <span class="literal">nullptr</span>, node *_pos = <span class="literal">nullptr</span>)</span></span></span><br><span class="line"><span class="function">                    :plist(_plist), pos(_pos) &#123;</span>&#125;</span><br><span class="line">            <span class="function"><span class="keyword">explicit</span> <span class="title">iterator</span><span class="params">(<span class="type">const</span> const_iterator &amp;other)</span></span></span><br><span class="line"><span class="function">                    :plist(other.getplist()), pos(other.getpos()) &#123;</span>&#125;</span><br><span class="line">            <span class="built_in">iterator</span>(<span class="type">const</span> iterator &amp;other) = <span class="keyword">default</span>;</span><br><span class="line">            ~<span class="built_in">iterator</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="type">const</span> list&lt;T&gt; *<span class="title">getplist</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> plist;&#125;</span><br><span class="line">            <span class="function">node *<span class="title">getpos</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> pos;&#125;</span><br><span class="line"></span><br><span class="line">            iterator <span class="keyword">operator</span>++(<span class="type">int</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(pos-&gt;next == <span class="literal">nullptr</span>)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="built_in">invalid_iterator</span>();</span><br><span class="line">                iterator temp = *<span class="keyword">this</span>;</span><br><span class="line">                pos = pos-&gt;next;</span><br><span class="line">                <span class="keyword">return</span> temp;</span><br><span class="line">            &#125;</span><br><span class="line">            iterator &amp; <span class="keyword">operator</span>++()</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(pos-&gt;next == <span class="literal">nullptr</span>)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="built_in">invalid_iterator</span>();</span><br><span class="line">                pos = pos-&gt;next;</span><br><span class="line">                <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            iterator <span class="keyword">operator</span>--(<span class="type">int</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(pos-&gt;prev-&gt;prev == <span class="literal">nullptr</span>)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="built_in">invalid_iterator</span>();</span><br><span class="line">                iterator temp = *<span class="keyword">this</span>;</span><br><span class="line">                pos = pos-&gt;prev;</span><br><span class="line">                <span class="keyword">return</span> temp;</span><br><span class="line">            &#125;</span><br><span class="line">            iterator &amp; <span class="keyword">operator</span>--()</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(pos-&gt;prev-&gt;prev == <span class="literal">nullptr</span>)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="built_in">invalid_iterator</span>();</span><br><span class="line">                pos = pos-&gt;prev;</span><br><span class="line">                <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            T &amp; <span class="keyword">operator</span> *() <span class="type">const</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(pos == <span class="literal">nullptr</span> || pos-&gt;prev == <span class="literal">nullptr</span> || pos-&gt;next == <span class="literal">nullptr</span>)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="built_in">invalid_iterator</span>();</span><br><span class="line">                <span class="keyword">return</span> *(pos-&gt;data);</span><br><span class="line">            &#125;</span><br><span class="line">            T * <span class="keyword">operator</span> -&gt;() <span class="type">const</span> <span class="keyword">noexcept</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(pos == <span class="literal">nullptr</span> || pos-&gt;prev == <span class="literal">nullptr</span> || pos-&gt;next == <span class="literal">nullptr</span>)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="built_in">invalid_iterator</span>();</span><br><span class="line">                <span class="keyword">return</span> pos-&gt;data;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> iterator &amp;rhs) <span class="type">const</span> &#123;<span class="keyword">return</span> plist == rhs.<span class="built_in">getplist</span>() &amp;&amp; pos == rhs.<span class="built_in">getpos</span>();&#125;</span><br><span class="line">            <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> const_iterator &amp;rhs) <span class="type">const</span> &#123;<span class="keyword">return</span> plist == rhs.<span class="built_in">getplist</span>() &amp;&amp; pos == rhs.<span class="built_in">getpos</span>();&#125;</span><br><span class="line">            <span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> iterator &amp;rhs) <span class="type">const</span> &#123;<span class="keyword">return</span> !(*<span class="keyword">this</span> == rhs);&#125;</span><br><span class="line">            <span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> const_iterator &amp;rhs) <span class="type">const</span> &#123;<span class="keyword">return</span> !(*<span class="keyword">this</span> == rhs);&#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">const_iterator</span></span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line">            <span class="type">const</span> list&lt;T&gt; *plist;</span><br><span class="line">            <span class="type">const</span> node *pos;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            <span class="function"><span class="keyword">explicit</span> <span class="title">const_iterator</span><span class="params">(<span class="type">const</span> list&lt;T&gt; *_plist = <span class="literal">nullptr</span>, node *_pos = <span class="literal">nullptr</span>)</span></span></span><br><span class="line"><span class="function">                    :plist(_plist), pos(_pos) &#123;</span>&#125;</span><br><span class="line">            <span class="function"><span class="keyword">explicit</span> <span class="title">const_iterator</span><span class="params">(<span class="type">const</span> iterator &amp;other)</span></span></span><br><span class="line"><span class="function">                    :plist(other.getplist()), pos(other.getpos()) &#123;</span>&#125;</span><br><span class="line">            <span class="built_in">const_iterator</span>(<span class="type">const</span> const_iterator &amp;other) = <span class="keyword">default</span>;</span><br><span class="line">            ~<span class="built_in">const_iterator</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="type">const</span> list&lt;T&gt; *<span class="title">getplist</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> plist;&#125;</span><br><span class="line">            <span class="function"><span class="type">const</span> node *<span class="title">getpos</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> pos;&#125;</span><br><span class="line"></span><br><span class="line">            const_iterator <span class="keyword">operator</span>++(<span class="type">int</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(pos-&gt;next == <span class="literal">nullptr</span>)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="built_in">invalid_iterator</span>();</span><br><span class="line">                const_iterator temp = *<span class="keyword">this</span>;</span><br><span class="line">                pos = pos-&gt;next;</span><br><span class="line">                <span class="keyword">return</span> temp;</span><br><span class="line">            &#125;</span><br><span class="line">            const_iterator &amp; <span class="keyword">operator</span>++()</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(pos-&gt;next == <span class="literal">nullptr</span>)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="built_in">invalid_iterator</span>();</span><br><span class="line">                pos = pos-&gt;next;</span><br><span class="line">                <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            const_iterator <span class="keyword">operator</span>--(<span class="type">int</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(pos-&gt;prev-&gt;prev == <span class="literal">nullptr</span>)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="built_in">invalid_iterator</span>();</span><br><span class="line">                const_iterator temp = *<span class="keyword">this</span>;</span><br><span class="line">                pos = pos-&gt;prev;</span><br><span class="line">                <span class="keyword">return</span> temp;</span><br><span class="line">            &#125;</span><br><span class="line">            const_iterator &amp; <span class="keyword">operator</span>--()</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(pos-&gt;prev-&gt;prev == <span class="literal">nullptr</span>)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="built_in">invalid_iterator</span>();</span><br><span class="line">                pos = pos-&gt;prev;</span><br><span class="line">                <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            T &amp; <span class="keyword">operator</span> *() <span class="type">const</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(pos == <span class="literal">nullptr</span> || pos-&gt;prev == <span class="literal">nullptr</span> || pos-&gt;next == <span class="literal">nullptr</span>)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="built_in">invalid_iterator</span>();</span><br><span class="line">                <span class="keyword">return</span> *pos-&gt;data;</span><br><span class="line">            &#125;</span><br><span class="line">            T * <span class="keyword">operator</span> -&gt;() <span class="type">const</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(pos == <span class="literal">nullptr</span> || pos-&gt;prev == <span class="literal">nullptr</span> || pos-&gt;next == <span class="literal">nullptr</span>)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="built_in">invalid_iterator</span>();</span><br><span class="line">                <span class="keyword">return</span> pos-&gt;data;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> iterator &amp;rhs) <span class="type">const</span> &#123;<span class="keyword">return</span> plist == rhs.<span class="built_in">getplist</span>() &amp;&amp; pos == rhs.<span class="built_in">getpos</span>();&#125;</span><br><span class="line">            <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> const_iterator &amp;rhs) <span class="type">const</span> &#123;<span class="keyword">return</span> plist == rhs.<span class="built_in">getplist</span>() &amp;&amp; pos == rhs.<span class="built_in">getpos</span>();&#125;</span><br><span class="line">            <span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> iterator &amp;rhs) <span class="type">const</span> &#123;<span class="keyword">return</span> !(*<span class="keyword">this</span> == rhs);&#125;</span><br><span class="line">            <span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> const_iterator &amp;rhs) <span class="type">const</span> &#123;<span class="keyword">return</span> !(*<span class="keyword">this</span> == rhs);&#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">list</span>() :<span class="built_in">head</span>(<span class="keyword">new</span> node), <span class="built_in">tail</span>(<span class="keyword">new</span> node), <span class="built_in">len</span>(<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            head-&gt;prev = <span class="literal">nullptr</span>;</span><br><span class="line">            head-&gt;next = tail;</span><br><span class="line">            tail-&gt;prev = head;</span><br><span class="line">            tail-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">list</span>(<span class="type">const</span> list &amp;other) :<span class="built_in">head</span>(<span class="keyword">new</span> node), <span class="built_in">tail</span>(<span class="keyword">new</span> node), <span class="built_in">len</span>(other.len)</span><br><span class="line">        &#123;</span><br><span class="line">            head-&gt;prev = <span class="literal">nullptr</span>;</span><br><span class="line">            head-&gt;next = tail;</span><br><span class="line">            tail-&gt;prev = head;</span><br><span class="line">            tail-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="keyword">for</span>(node *i = other.head-&gt;next; i != other.tail; i = i-&gt;next)</span><br><span class="line">            &#123;</span><br><span class="line">                node *add = <span class="keyword">new</span> <span class="built_in">node</span>(*i-&gt;data, tail-&gt;prev, tail);</span><br><span class="line">                tail-&gt;prev-&gt;next = add;</span><br><span class="line">                tail-&gt;prev = add;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">virtual</span> ~<span class="built_in">list</span>()</span><br><span class="line">        &#123;</span><br><span class="line">            node *p = head, *q = head;</span><br><span class="line">            <span class="keyword">while</span>(q != <span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                q = p-&gt;next;</span><br><span class="line">                <span class="keyword">delete</span> p;</span><br><span class="line">                p = q;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        list &amp;<span class="keyword">operator</span>=(<span class="type">const</span> list &amp;other)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(&amp;other != <span class="keyword">this</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">clear</span>();</span><br><span class="line">                len = other.len;</span><br><span class="line">                <span class="keyword">for</span>(node *i = other.head-&gt;next; i != other.tail; i = i-&gt;next)</span><br><span class="line">                &#123;</span><br><span class="line">                    node *add = <span class="keyword">new</span> <span class="built_in">node</span>(*i-&gt;data, tail-&gt;prev, tail);</span><br><span class="line">                    tail-&gt;prev-&gt;next = add;</span><br><span class="line">                    tail-&gt;prev = add;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">const</span> T &amp; <span class="title">front</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(!len)</span><br><span class="line">                <span class="keyword">throw</span> <span class="built_in">container_is_empty</span>();</span><br><span class="line">            <span class="keyword">return</span> *head-&gt;next-&gt;data;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">const</span> T &amp; <span class="title">back</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(!len)</span><br><span class="line">                <span class="keyword">throw</span> <span class="built_in">container_is_empty</span>();</span><br><span class="line">            <span class="keyword">return</span> *tail-&gt;prev-&gt;data;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> <span class="built_in">iterator</span>(<span class="keyword">this</span>, head-&gt;next);&#125;</span><br><span class="line">        <span class="function">const_iterator <span class="title">cbegin</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> <span class="built_in">const_iterator</span>(<span class="keyword">this</span>, head-&gt;next);&#125;</span><br><span class="line">        <span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> <span class="built_in">iterator</span>(<span class="keyword">this</span>, tail);&#125;</span><br><span class="line">        <span class="function">const_iterator <span class="title">cend</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> <span class="built_in">const_iterator</span>(<span class="keyword">this</span>, tail);&#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> !len;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> len;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            len = <span class="number">0</span>;</span><br><span class="line">            node *p = head-&gt;next, *q;</span><br><span class="line">            <span class="keyword">while</span>(p != tail)</span><br><span class="line">            &#123;</span><br><span class="line">                q = p;</span><br><span class="line">                p = p-&gt;next;</span><br><span class="line">                <span class="keyword">delete</span> q;</span><br><span class="line">            &#125;</span><br><span class="line">            head-&gt;next = tail;</span><br><span class="line">            tail-&gt;prev = head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> iterator <span class="title">insert</span><span class="params">(iterator pos, <span class="type">const</span> T &amp;value)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(pos.<span class="built_in">getplist</span>() == <span class="literal">nullptr</span> || pos.<span class="built_in">getplist</span>() != <span class="keyword">this</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="built_in">invalid_iterator</span>();</span><br><span class="line">            node *npos = pos.<span class="built_in">getpos</span>();</span><br><span class="line">            <span class="keyword">if</span>(npos == head)</span><br><span class="line">                <span class="keyword">throw</span> <span class="built_in">invalid_iterator</span>();</span><br><span class="line"></span><br><span class="line">            ++len;</span><br><span class="line">            node *add = <span class="keyword">new</span> <span class="built_in">node</span>(value, npos-&gt;prev, npos);</span><br><span class="line">            add-&gt;prev-&gt;next = add;</span><br><span class="line">            add-&gt;next-&gt;prev = add;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">iterator</span>(<span class="keyword">this</span>, add);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> iterator <span class="title">erase</span><span class="params">(iterator pos)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(pos.<span class="built_in">getplist</span>() == <span class="literal">nullptr</span> || pos.<span class="built_in">getplist</span>() != <span class="keyword">this</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="built_in">invalid_iterator</span>();</span><br><span class="line">            <span class="keyword">if</span>(!len)</span><br><span class="line">                <span class="keyword">throw</span> <span class="built_in">container_is_empty</span>();</span><br><span class="line">            node *npos = pos.<span class="built_in">getpos</span>();</span><br><span class="line">            <span class="keyword">if</span>(npos == head || npos == tail)</span><br><span class="line">                <span class="keyword">throw</span> <span class="built_in">invalid_iterator</span>();</span><br><span class="line"></span><br><span class="line">            --len;</span><br><span class="line">            npos-&gt;next-&gt;prev = npos-&gt;prev;</span><br><span class="line">            npos-&gt;prev-&gt;next = npos-&gt;next;</span><br><span class="line">            iterator ret = <span class="built_in">iterator</span>(<span class="keyword">this</span>, npos-&gt;next);</span><br><span class="line">            <span class="keyword">delete</span> npos;</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(<span class="type">const</span> T &amp;value)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            ++len;</span><br><span class="line">            node *add = <span class="keyword">new</span> <span class="built_in">node</span>(value, tail-&gt;prev, tail);</span><br><span class="line">            tail-&gt;prev-&gt;next = add;</span><br><span class="line">            tail-&gt;prev = add;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">pop_back</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(!len)</span><br><span class="line">                <span class="keyword">throw</span> <span class="built_in">container_is_empty</span>();</span><br><span class="line">            --len;</span><br><span class="line">            node *del = tail-&gt;prev;</span><br><span class="line">            del-&gt;prev-&gt;next = del-&gt;next;</span><br><span class="line">            del-&gt;next-&gt;prev = del-&gt;prev;</span><br><span class="line">            <span class="keyword">delete</span> del;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">push_front</span><span class="params">(<span class="type">const</span> T &amp;value)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            ++len;</span><br><span class="line">            node *add = <span class="keyword">new</span> <span class="built_in">node</span>(value, head, head-&gt;next);</span><br><span class="line">            head-&gt;next-&gt;prev = add;</span><br><span class="line">            head-&gt;next = add;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">pop_front</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(!len)</span><br><span class="line">                <span class="keyword">throw</span> <span class="built_in">container_is_empty</span>();</span><br><span class="line">            --len;</span><br><span class="line">            node *del = head-&gt;next;</span><br><span class="line">            del-&gt;prev-&gt;next = del-&gt;next;</span><br><span class="line">            del-&gt;next-&gt;prev = del-&gt;prev;</span><br><span class="line">            <span class="keyword">delete</span> del;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">sort</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(!len) <span class="keyword">return</span>;</span><br><span class="line">            T *temp = (T *)<span class="built_in">malloc</span>(len * <span class="built_in">sizeof</span>(T));</span><br><span class="line">            node *p = head-&gt;next;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; p = p-&gt;next, ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">new</span>(temp + i) <span class="built_in">T</span>(*p-&gt;data);</span><br><span class="line">                p-&gt;data-&gt;~<span class="built_in">T</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            sjtu::<span class="built_in">sort</span>&lt;T&gt;(temp, temp + len, [](<span class="type">const</span> T &amp;a, <span class="type">const</span> T &amp;b) &#123;<span class="keyword">return</span> a &lt; b;&#125;);</span><br><span class="line">            p = head-&gt;next;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; p = p-&gt;next, ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">new</span>(p-&gt;data) <span class="built_in">T</span>(temp[i]);</span><br><span class="line">                temp[i].~<span class="built_in">T</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">free</span>(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(list &amp;other)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(!other.len) <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">for</span>(node *p = head-&gt;next, *q = other.head-&gt;next; q != other.tail; )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(p == tail || *q-&gt;data &lt; *p-&gt;data)</span><br><span class="line">                &#123;</span><br><span class="line">                    node *temp = other.<span class="built_in">erase</span>(q);</span><br><span class="line">                    q = temp-&gt;next;</span><br><span class="line">                    <span class="built_in">insert</span>(p, temp);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> p = p-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">reverse</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(!len) <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">for</span>(node *p = head; p != <span class="literal">nullptr</span>; p = p-&gt;prev)</span><br><span class="line">            &#123;</span><br><span class="line">                node* temp = p-&gt;next;</span><br><span class="line">                p-&gt;next = p-&gt;prev;</span><br><span class="line">                p-&gt;prev = temp;</span><br><span class="line">            &#125;</span><br><span class="line">            node *temp = head;</span><br><span class="line">            head = tail;</span><br><span class="line">            tail = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">unique</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(!len) <span class="keyword">return</span>;</span><br><span class="line">            T rec = *head-&gt;next-&gt;data;</span><br><span class="line">            <span class="keyword">for</span>(node *p = head-&gt;next-&gt;next; p != tail; )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(*p-&gt;data == rec)</span><br><span class="line">                &#123;</span><br><span class="line">                    node *del = <span class="built_in">erase</span>(p);</span><br><span class="line">                    p = p-&gt;next;</span><br><span class="line">                    <span class="keyword">delete</span> del;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    rec = *p-&gt;data;</span><br><span class="line">                    p = p-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125; <span class="comment">// namespace sjtu</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//SJTU_LIST_HPP</span></span></span><br></pre></td></tr></table></figure>
<hr>
<h1 id="priority_queue">priority_queue</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Finished by MeteorVanish on 2022.4.9</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SJTU_PRIORITY_QUEUE_HPP</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SJTU_PRIORITY_QUEUE_HPP</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstddef&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;exceptions.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> sjtu</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">class</span> <span class="title class_">Compare</span> = std::less&lt;T&gt;&gt;</span><br><span class="line">    <span class="keyword">class</span> priority_queue</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">struct</span> node</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">size_t</span> height;</span><br><span class="line">            T data;</span><br><span class="line">            node *child, *sibling;</span><br><span class="line">            <span class="built_in">node</span>(<span class="type">size_t</span> _height, T _data, node *_child = <span class="literal">nullptr</span>, node *_sibling = <span class="literal">nullptr</span>)</span><br><span class="line">                    :<span class="built_in">height</span>(_height), <span class="built_in">data</span>(_data), <span class="built_in">child</span>(_child), <span class="built_in">sibling</span>(_sibling) &#123;&#125;</span><br><span class="line">            ~<span class="built_in">node</span>() = <span class="keyword">default</span>;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">size_t</span> nowHeapNum, maxHeapNum;</span><br><span class="line">        node **head;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">DoubleSpace</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            node **temp = head;</span><br><span class="line">            <span class="keyword">delete</span>[] head;</span><br><span class="line">            maxHeapNum *= <span class="number">2</span>;</span><br><span class="line">            head = <span class="keyword">new</span> node *[maxHeapNum];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">1</span>; i &lt;= nowHeapNum; ++i)</span><br><span class="line">                head[i] = temp[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">node *<span class="title">Union</span><span class="params">(node *a, node *b)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">Compare</span>() (a-&gt;data, b-&gt;data))</span><br><span class="line">                std::<span class="built_in">swap</span>(a, b);</span><br><span class="line">            a-&gt;sibling = b-&gt;child;</span><br><span class="line">            b-&gt;child = a;</span><br><span class="line">            ++b-&gt;height;</span><br><span class="line">            <span class="keyword">return</span> b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">MergeSubHeap</span><span class="params">(node *x)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="type">size_t</span> h = x-&gt;height;</span><br><span class="line">            <span class="keyword">if</span>(h &gt; nowHeapNum)</span><br><span class="line">            &#123;</span><br><span class="line">                nowHeapNum = h;</span><br><span class="line">                head[h] = x;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">size_t</span> i = h; i &lt;= nowHeapNum; ++i)</span><br><span class="line">                <span class="keyword">if</span>(head[i])</span><br><span class="line">                &#123;</span><br><span class="line">                    x = <span class="built_in">Union</span>(head[i], x);</span><br><span class="line">                    head[i] = <span class="literal">nullptr</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    head[i] = x;</span><br><span class="line">                    flag = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">if</span>(!flag)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(nowHeapNum == maxHeapNum - <span class="number">1</span>) <span class="built_in">DoubleSpace</span>();</span><br><span class="line">                head[++nowHeapNum] = x;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">CopySubHeap</span><span class="params">(node *&amp;pos, node *other)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(other == <span class="literal">nullptr</span>) &#123;pos = <span class="literal">nullptr</span>; <span class="keyword">return</span>;&#125;</span><br><span class="line">            pos = <span class="keyword">new</span> <span class="built_in">node</span>(other-&gt;height, other-&gt;data);</span><br><span class="line">            <span class="built_in">CopySubHeap</span>(pos-&gt;child, other-&gt;child);</span><br><span class="line">            <span class="built_in">CopySubHeap</span>(pos-&gt;sibling, other-&gt;sibling);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">ClearSubHeap</span><span class="params">(node *pos)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(pos == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">            <span class="built_in">ClearSubHeap</span>(pos-&gt;child);</span><br><span class="line">            <span class="built_in">ClearSubHeap</span>(pos-&gt;sibling);</span><br><span class="line">            <span class="keyword">delete</span> pos;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">ClearAllSubHeap</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">1</span>; i &lt;= nowHeapNum; ++i)</span><br><span class="line">                <span class="keyword">if</span>(head[i]) <span class="built_in">ClearSubHeap</span>(head[i]);</span><br><span class="line">            nowHeapNum = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">pop_AddSubHeap</span><span class="params">(node *pos)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(pos == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">if</span>(pos-&gt;height &gt; <span class="number">1</span>)</span><br><span class="line">                <span class="built_in">pop_AddSubHeap</span>(pos-&gt;sibling);</span><br><span class="line">            pos-&gt;sibling = <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="built_in">MergeSubHeap</span>(pos);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">size_t</span> <span class="title">FindTopSubHeap</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="type">size_t</span> pos;</span><br><span class="line">            <span class="keyword">for</span>(pos = <span class="number">1</span>; pos &lt;= nowHeapNum; ++pos)</span><br><span class="line">                <span class="keyword">if</span>(head[pos]) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">size_t</span> i = pos + <span class="number">1</span>; i &lt;= nowHeapNum; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(head[i] == <span class="literal">nullptr</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(!<span class="built_in">Compare</span>() (head[i]-&gt;data, head[pos]-&gt;data))</span><br><span class="line">                    pos = i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> pos;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">priority_queue</span>() :<span class="built_in">nowHeapNum</span>(<span class="number">0</span>), <span class="built_in">maxHeapNum</span>(<span class="number">100</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            head = <span class="keyword">new</span> node *[maxHeapNum];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">priority_queue</span>(<span class="type">const</span> priority_queue &amp;other) :<span class="built_in">nowHeapNum</span>(other.nowHeapNum), <span class="built_in">maxHeapNum</span>(other.maxHeapNum)</span><br><span class="line">        &#123;</span><br><span class="line">            head = <span class="keyword">new</span> node *[maxHeapNum];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">1</span>; i &lt;= nowHeapNum; ++i)</span><br><span class="line">                <span class="built_in">CopySubHeap</span>(head[i], other.head[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        ~<span class="built_in">priority_queue</span>()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">ClearAllSubHeap</span>();</span><br><span class="line">            <span class="keyword">delete</span>[] head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        priority_queue &amp;<span class="keyword">operator</span>=(<span class="type">const</span> priority_queue &amp;other)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span> != &amp;other)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">ClearAllSubHeap</span>();</span><br><span class="line">                <span class="keyword">delete</span>[] head;</span><br><span class="line">                nowHeapNum = other.nowHeapNum;</span><br><span class="line">                maxHeapNum = other.maxHeapNum;</span><br><span class="line">                head = <span class="keyword">new</span> node *[maxHeapNum];</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">1</span>; i &lt;= nowHeapNum; ++i)</span><br><span class="line">                    <span class="built_in">CopySubHeap</span>(head[i], other.head[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">const</span> T &amp; <span class="title">top</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">empty</span>())</span><br><span class="line">                <span class="keyword">throw</span> <span class="built_in">container_is_empty</span>();</span><br><span class="line">            <span class="type">size_t</span> pos = <span class="built_in">FindTopSubHeap</span>();</span><br><span class="line">            <span class="keyword">return</span> head[pos]-&gt;data;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">const</span> T &amp;e)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            node *add = <span class="keyword">new</span> <span class="built_in">node</span>(<span class="number">1</span>, e);</span><br><span class="line">            <span class="built_in">MergeSubHeap</span>(add);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">empty</span>())</span><br><span class="line">                <span class="keyword">throw</span> <span class="built_in">container_is_empty</span>();</span><br><span class="line">            <span class="type">size_t</span> pos = <span class="built_in">FindTopSubHeap</span>();</span><br><span class="line">            node *temp = head[pos]-&gt;child;</span><br><span class="line">            <span class="keyword">delete</span> head[pos], head[pos] = <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="built_in">pop_AddSubHeap</span>(temp);</span><br><span class="line">            <span class="keyword">if</span>(head[nowHeapNum] == <span class="literal">nullptr</span>) --nowHeapNum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="type">size_t</span> cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">1</span>; i &lt;= nowHeapNum; ++i)</span><br><span class="line">                <span class="keyword">if</span>(head[i]) cnt += <span class="number">1</span> &lt;&lt; i - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> cnt;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> !nowHeapNum;&#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(priority_queue &amp;other)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(other.<span class="built_in">empty</span>()) <span class="keyword">return</span>;</span><br><span class="line">            node *temp;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">1</span>; i &lt;= other.nowHeapNum; ++i)</span><br><span class="line">                <span class="keyword">if</span>(other.head[i])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">CopySubHeap</span>(temp, other.head[i]);</span><br><span class="line">                    <span class="built_in">MergeSubHeap</span>(temp);</span><br><span class="line">                &#125;</span><br><span class="line">            other.<span class="built_in">ClearAllSubHeap</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125; <span class="comment">// namespace sjtu</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//SJTU_PRIORITY_QUEUE_HPP</span></span></span><br></pre></td></tr></table></figure>
<hr>
<h1 id="linked_hashmap">linked_hashmap</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Finished by MeteorVanish on 2022.5.4</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SJTU_LINKED_HASHMAP_HPP_STD</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SJTU_LINKED_HASHMAP_HPP_STD</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstddef&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;utility.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;algorithm.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;exceptions.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;list.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> sjtu</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Key</span>, <span class="keyword">class</span> <span class="title class_">Value</span>, <span class="keyword">class</span> <span class="title class_">Hash</span> = std::hash&lt;Key&gt;, <span class="keyword">class</span> Equal = std::equal_to&lt;Key&gt; &gt;</span><br><span class="line">    <span class="keyword">class</span> linked_hashmap : <span class="keyword">public</span> list&lt;pair&lt;<span class="type">const</span> Key, Value&gt; &gt;</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">using</span> value_type = pair&lt;<span class="type">const</span> Key, Value&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">Node</span> : <span class="keyword">public</span> list&lt;value_type&gt;::node</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            Node* after;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            * list&lt;value_type&gt;::node:</span></span><br><span class="line"><span class="comment">            *     value_type *val;</span></span><br><span class="line"><span class="comment">            *     node *prv, *nxt;</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">Node</span>()</span><br><span class="line">                : list&lt;value_type&gt;::<span class="built_in">node</span>(), <span class="built_in">after</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">            <span class="function"><span class="keyword">explicit</span> <span class="title">Node</span><span class="params">(<span class="type">const</span> value_type &amp;_val, Node* _after = <span class="literal">nullptr</span>)</span></span></span><br><span class="line"><span class="function">                : list&lt;value_type&gt;::node(_val), after(_after) &#123;</span>&#125;</span><br><span class="line">            ~<span class="built_in">Node</span>() = <span class="keyword">default</span>;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">BucketList</span></span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            Node* _head;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">BucketList</span>() : _head(<span class="keyword">new</span> Node) &#123;&#125;</span><br><span class="line">            ~<span class="built_in">BucketList</span>() &#123;<span class="keyword">delete</span> _head;&#125;</span><br><span class="line"></span><br><span class="line">            <span class="function">Node * <span class="title">find</span><span class="params">(<span class="type">const</span> Key &amp;o)</span></span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                Node* p = _head-&gt;after;</span><br><span class="line">                <span class="keyword">while</span>(p != <span class="literal">nullptr</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(<span class="built_in">Equal</span>()(p-&gt;val-&gt;first, o)) <span class="keyword">break</span>;</span><br><span class="line">                    p = p-&gt;after;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function">Node * <span class="title">insert</span><span class="params">(<span class="type">const</span> Key &amp;k, <span class="type">const</span> Value &amp;v)</span></span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                Node* add = <span class="keyword">new</span> <span class="built_in">Node</span>(<span class="built_in">value_type</span>(k, v), _head-&gt;after);</span><br><span class="line">                _head-&gt;after = add;</span><br><span class="line">                <span class="keyword">return</span> add;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function">Node * <span class="title">insert</span><span class="params">(<span class="type">const</span> value_type &amp;kv)</span></span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                Node* add = <span class="keyword">new</span> <span class="built_in">Node</span>(kv, _head-&gt;after);</span><br><span class="line">                _head-&gt;after = add;</span><br><span class="line">                <span class="keyword">return</span> add;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function">Node * <span class="title">erase</span><span class="params">(<span class="type">const</span> Key &amp;k)</span></span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                Node *p = _head, *q;</span><br><span class="line">                <span class="keyword">while</span>(p != <span class="literal">nullptr</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    q = p-&gt;after;</span><br><span class="line">                    <span class="keyword">if</span>(<span class="built_in">Equal</span>()(q-&gt;val-&gt;first, k))</span><br><span class="line">                    &#123;</span><br><span class="line">                        p-&gt;after = q-&gt;after;</span><br><span class="line">                        <span class="keyword">return</span> q;</span><br><span class="line">                    &#125;</span><br><span class="line">                    p = q;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">double</span> LoadFactor = <span class="number">0.75</span>;</span><br><span class="line">        <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">size_t</span> InitSize = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">size_t</span> Capacity;</span><br><span class="line">        BucketList* storage;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * list&lt;pair&lt;const Key, Value&gt; &gt;:</span></span><br><span class="line"><span class="comment">        *     size_t num;</span></span><br><span class="line"><span class="comment">        *     node *head, *tail, *nil;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">resize</span><span class="params">(<span class="type">size_t</span> newCapacity)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            Capacity = newCapacity;</span><br><span class="line">            <span class="keyword">delete</span>[] storage;</span><br><span class="line">            storage = <span class="keyword">new</span> BucketList[Capacity];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">typename</span> list&lt;value_type&gt;::node* p = list&lt;value_type&gt;::head-&gt;nxt;</span><br><span class="line">                p != list&lt;value_type&gt;::nil; p = p-&gt;nxt)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">size_t</span> _hash = <span class="built_in">Hash</span>()(p-&gt;val-&gt;first) % Capacity;</span><br><span class="line">                Node *q = <span class="built_in">dynamic_cast</span>&lt;Node*&gt;(p), *hashHead = storage[_hash]._head;</span><br><span class="line">                q-&gt;after = hashHead-&gt;after;</span><br><span class="line">                hashHead-&gt;after = q;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">using</span> iterator = <span class="keyword">typename</span> list&lt;value_type&gt;::iterator;</span><br><span class="line">        <span class="keyword">using</span> const_iterator = <span class="keyword">typename</span> list&lt;value_type&gt;::const_iterator;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">linked_hashmap</span>() : <span class="built_in">list</span>&lt;value_type&gt;(), <span class="built_in">Capacity</span>(InitSize) &#123; storage = <span class="keyword">new</span> BucketList[Capacity]; &#125;</span><br><span class="line">        <span class="built_in">linked_hashmap</span>(<span class="type">const</span> linked_hashmap &amp;other)</span><br><span class="line">        &#123;</span><br><span class="line">            Capacity = other.Capacity;</span><br><span class="line">            list&lt;value_type&gt;::num = <span class="number">0</span>;</span><br><span class="line">            storage = <span class="keyword">new</span> BucketList[Capacity];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">typename</span> list&lt;value_type&gt;::node* p = other.head-&gt;nxt; p != other.nil; p = p-&gt;nxt)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">size_t</span> _hash = <span class="built_in">Hash</span>()(p-&gt;val-&gt;first) % Capacity;</span><br><span class="line">                Node* add = storage[_hash].<span class="built_in">insert</span>(*p-&gt;val);</span><br><span class="line">                list&lt;value_type&gt;::<span class="built_in">insert</span>(list&lt;value_type&gt;::nil, add);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        linked_hashmap &amp;<span class="keyword">operator</span>=(<span class="type">const</span> linked_hashmap &amp;other)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span> == &amp;other) <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">            list&lt;value_type&gt;::<span class="built_in">clear</span>();</span><br><span class="line">            <span class="keyword">delete</span>[] storage;</span><br><span class="line">            Capacity = other.Capacity;</span><br><span class="line">            list&lt;value_type&gt;::num = <span class="number">0</span>;</span><br><span class="line">            storage = <span class="keyword">new</span> BucketList[Capacity];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">typename</span> list&lt;value_type&gt;::node* p = other.head-&gt;nxt; p != other.nil; p = p-&gt;nxt)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">size_t</span> _hash = <span class="built_in">Hash</span>()(p-&gt;val-&gt;first) % Capacity;</span><br><span class="line">                Node* add = storage[_hash].<span class="built_in">insert</span>(*p-&gt;val);</span><br><span class="line">                list&lt;value_type&gt;::<span class="built_in">insert</span>(list&lt;value_type&gt;::nil, add);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ~<span class="built_in">linked_hashmap</span>() &#123; <span class="keyword">delete</span>[] storage; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">Value &amp;<span class="title">at</span><span class="params">(<span class="type">const</span> Key &amp;key)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="type">size_t</span> _hash = <span class="built_in">Hash</span>()(key) % Capacity;</span><br><span class="line">            Node* p = storage[_hash].<span class="built_in">find</span>(key);</span><br><span class="line">            <span class="keyword">if</span>(p == <span class="literal">nullptr</span>) <span class="keyword">throw</span> <span class="built_in">index_out_of_bound</span>();</span><br><span class="line">            <span class="keyword">return</span> p-&gt;val-&gt;second;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">const</span> Value &amp;<span class="title">at</span><span class="params">(<span class="type">const</span> Key &amp;key)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="type">size_t</span> _hash = <span class="built_in">Hash</span>()(key) % Capacity;</span><br><span class="line">            Node* p = storage[_hash].<span class="built_in">find</span>(key);</span><br><span class="line">            <span class="keyword">if</span>(p == <span class="literal">nullptr</span>) <span class="keyword">throw</span> <span class="built_in">index_out_of_bound</span>();</span><br><span class="line">            <span class="keyword">return</span> p-&gt;val-&gt;second;</span><br><span class="line">        &#125;</span><br><span class="line">        Value &amp;<span class="keyword">operator</span>[](<span class="type">const</span> Key &amp;key)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">size_t</span> _hash = <span class="built_in">Hash</span>()(key) % Capacity;</span><br><span class="line">            Node* p = storage[_hash].<span class="built_in">find</span>(key);</span><br><span class="line">            <span class="keyword">if</span>(p == <span class="literal">nullptr</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">insert</span>(<span class="built_in">value_type</span>(key, <span class="built_in">Value</span>())).first-&gt;second;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> p-&gt;val-&gt;second;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">const</span> Value &amp;<span class="keyword">operator</span>[](<span class="type">const</span> Key &amp;key) <span class="type">const</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">size_t</span> _hash = <span class="built_in">Hash</span>()(key) % Capacity;</span><br><span class="line">            Node* p = storage[_hash].<span class="built_in">find</span>(key);</span><br><span class="line">            <span class="keyword">if</span>(p == <span class="literal">nullptr</span>) <span class="keyword">throw</span> <span class="built_in">index_out_of_bound</span>();</span><br><span class="line">            <span class="keyword">return</span> p-&gt;val-&gt;second;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            list&lt;value_type&gt;::<span class="built_in">clear</span>();</span><br><span class="line">            <span class="keyword">delete</span>[] storage;</span><br><span class="line">            Capacity = InitSize;</span><br><span class="line">            storage = <span class="keyword">new</span> BucketList[Capacity];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">pair&lt;iterator, <span class="type">bool</span>&gt; <span class="title">insert</span><span class="params">(<span class="type">const</span> value_type &amp;value)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="type">size_t</span> _hash = <span class="built_in">Hash</span>()(value.first) % Capacity;</span><br><span class="line">            Node* p = storage[_hash].<span class="built_in">find</span>(value.first);</span><br><span class="line">            <span class="keyword">if</span>(p != <span class="literal">nullptr</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">pair</span>&lt;iterator, <span class="type">bool</span>&gt;(<span class="built_in">iterator</span>(p, <span class="keyword">this</span>), <span class="literal">false</span>);</span><br><span class="line">            p = storage[_hash].<span class="built_in">insert</span>(value);</span><br><span class="line">            list&lt;value_type&gt;::<span class="built_in">insert</span>(list&lt;value_type&gt;::nil, p);</span><br><span class="line">            <span class="keyword">if</span>(list&lt;value_type&gt;::num &gt; Capacity * LoadFactor) <span class="built_in">resize</span>(Capacity &lt;&lt; <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">pair</span>&lt;iterator, <span class="type">bool</span>&gt;(<span class="built_in">iterator</span>(p, <span class="keyword">this</span>), <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">iterator <span class="title">erase</span><span class="params">(iterator pos)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(pos.<span class="built_in">invalid</span>(<span class="keyword">this</span>)) <span class="keyword">throw</span> <span class="built_in">invalid_iterator</span>();</span><br><span class="line">            <span class="type">size_t</span> _hash = <span class="built_in">Hash</span>()((*pos).first) % Capacity;</span><br><span class="line">            Node* p = storage[_hash].<span class="built_in">erase</span>(pos-&gt;first);</span><br><span class="line">            <span class="keyword">if</span>(p == <span class="literal">nullptr</span>) <span class="keyword">throw</span> <span class="built_in">invalid_iterator</span>();</span><br><span class="line">            list&lt;value_type&gt;::<span class="built_in">erase</span>(pos);</span><br><span class="line">            <span class="keyword">if</span>(Capacity &gt;&gt; <span class="number">1</span> &gt;= InitSize &amp;&amp; list&lt;value_type&gt;::num &lt; (Capacity &gt;&gt; <span class="number">2</span>) * LoadFactor)</span><br><span class="line">                <span class="built_in">resize</span>(Capacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>-&gt;<span class="built_in">begin</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">size_t</span> <span class="title">count</span><span class="params">(<span class="type">const</span> Key &amp;key)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="type">size_t</span> _hash = <span class="built_in">Hash</span>()(key) % Capacity;</span><br><span class="line">            <span class="keyword">return</span> storage[_hash].<span class="built_in">find</span>(key) != <span class="literal">nullptr</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">iterator <span class="title">find</span><span class="params">(<span class="type">const</span> Key &amp;key)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="type">size_t</span> _hash = <span class="built_in">Hash</span>()(key) % Capacity;</span><br><span class="line">            Node* p = storage[_hash].<span class="built_in">find</span>(key);</span><br><span class="line">            <span class="keyword">if</span>(p != <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="built_in">iterator</span>(p, <span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> list&lt;value_type&gt;::<span class="built_in">end</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">const_iterator <span class="title">find</span><span class="params">(<span class="type">const</span> Key &amp;key)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="type">size_t</span> _hash = <span class="built_in">Hash</span>()(key) % Capacity;</span><br><span class="line">            Node* p = storage[_hash].<span class="built_in">find</span>(key);</span><br><span class="line">            <span class="keyword">if</span>(p != <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="built_in">const_iterator</span>(p, <span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> list&lt;value_type&gt;::<span class="built_in">cend</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125; <span class="comment">// namespace sjtu</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//SJTU_LINKED_HASHMAP_HPP_STD</span></span></span><br></pre></td></tr></table></figure>
<hr>
<h1 id="map">map</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Finished by MeteorVanish on 2022.6.1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Implemented with AVL tree</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SJTU_MAP_HPP</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SJTU_MAP_HPP</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstddef&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;utility.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;exceptions.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> sjtu</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Key</span>, <span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Compare</span> = std::less&lt;Key&gt; &gt;</span><br><span class="line">    <span class="keyword">class</span> map</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">typedef</span> pair&lt;<span class="type">const</span> Key, T&gt; value_type;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">Equal</span><span class="params">(<span class="type">const</span> Key &amp;x, <span class="type">const</span> Key &amp;y)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> !(<span class="built_in">Compare</span>()(x, y) || <span class="built_in">Compare</span>()(y, x)); &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">        &#123;</span><br><span class="line">            value_type *data;</span><br><span class="line">            <span class="type">size_t</span> height;</span><br><span class="line">            Node *Lchild, *Rchild;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">Node</span>() :<span class="built_in">data</span>(<span class="literal">nullptr</span>), <span class="built_in">height</span>(<span class="number">0</span>), <span class="built_in">Lchild</span>(<span class="literal">nullptr</span>), <span class="built_in">Rchild</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">            <span class="built_in">Node</span>(<span class="type">const</span> value_type &amp;_data)</span><br><span class="line">                    :<span class="built_in">data</span>(<span class="keyword">new</span> <span class="built_in">value_type</span>(_data)), <span class="built_in">height</span>(<span class="number">1</span>), <span class="built_in">Lchild</span>(<span class="literal">nullptr</span>), <span class="built_in">Rchild</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">            ~<span class="built_in">Node</span>() &#123; <span class="keyword">delete</span> data; &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Node* root;</span><br><span class="line">        Node* nil;</span><br><span class="line">        <span class="type">size_t</span> Size;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">size_t</span> <span class="title">GetHeight</span><span class="params">(Node *t)</span> </span>&#123; <span class="keyword">return</span> t ? t-&gt;height : <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">AdjustHeight</span><span class="params">(Node *t)</span> </span>&#123;t-&gt;height = std::<span class="built_in">max</span>(<span class="built_in">GetHeight</span>(t-&gt;Lchild), <span class="built_in">GetHeight</span>(t-&gt;Rchild)) + <span class="number">1</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">LL</span><span class="params">(Node *&amp;t)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            Node* tLC = t-&gt;Lchild;</span><br><span class="line">            t-&gt;Lchild = tLC-&gt;Rchild;</span><br><span class="line">            tLC-&gt;Rchild = t;</span><br><span class="line">            <span class="built_in">AdjustHeight</span>(t);</span><br><span class="line">            <span class="built_in">AdjustHeight</span>(tLC);</span><br><span class="line">            t = tLC;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">RR</span><span class="params">(Node *&amp;t)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            Node* tRC = t-&gt;Rchild;</span><br><span class="line">            t-&gt;Rchild = tRC-&gt;Lchild;</span><br><span class="line">            tRC-&gt;Lchild = t;</span><br><span class="line">            <span class="built_in">AdjustHeight</span>(t);</span><br><span class="line">            <span class="built_in">AdjustHeight</span>(tRC);</span><br><span class="line">            t = tRC;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">LR</span><span class="params">(Node *&amp;t)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="built_in">RR</span>(t-&gt;Lchild);</span><br><span class="line">            <span class="built_in">LL</span>(t);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">RL</span><span class="params">(Node *&amp;t)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="built_in">LL</span>(t-&gt;Rchild);</span><br><span class="line">            <span class="built_in">RR</span>(t);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">Clear</span><span class="params">(Node *&amp;t)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(t == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">            <span class="built_in">Clear</span>(t-&gt;Lchild);</span><br><span class="line">            <span class="built_in">Clear</span>(t-&gt;Rchild);</span><br><span class="line">            <span class="keyword">delete</span> t;</span><br><span class="line">            t = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">Node* <span class="title">Find</span><span class="params">(<span class="type">const</span> Key &amp;target, Node *t)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(t == <span class="literal">nullptr</span>) <span class="keyword">return</span> nil;</span><br><span class="line">            <span class="type">const</span> Key &amp;cur = t-&gt;data-&gt;first;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">Equal</span>(cur, target)) <span class="keyword">return</span> t;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">Compare</span>()(target, cur)) <span class="keyword">return</span> <span class="built_in">Find</span>(target, t-&gt;Lchild);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">Find</span>(target, t-&gt;Rchild);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">Node* <span class="title">Find</span><span class="params">(<span class="type">const</span> Key &amp;target)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">Find</span>(target, root); &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">Node* <span class="title">Insert</span><span class="params">(<span class="type">const</span> value_type &amp;val, Node* &amp;t)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            Node* ret;</span><br><span class="line">            <span class="keyword">if</span>(t == <span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                t = <span class="keyword">new</span> <span class="built_in">Node</span>(val);</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">Equal</span>(val.first, t-&gt;data-&gt;first)) <span class="keyword">return</span> t;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">Compare</span>()(val.first, t-&gt;data-&gt;first))</span><br><span class="line">            &#123;</span><br><span class="line">                ret = <span class="built_in">Insert</span>(val, t-&gt;Lchild);</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">GetHeight</span>(t-&gt;Lchild) - <span class="built_in">GetHeight</span>(t-&gt;Rchild) == <span class="number">2</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(<span class="built_in">Compare</span>()(val.first, t-&gt;Lchild-&gt;data-&gt;first)) <span class="built_in">LL</span>(t);</span><br><span class="line">                    <span class="keyword">else</span> <span class="built_in">LR</span>(t);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                ret = <span class="built_in">Insert</span>(val, t-&gt;Rchild);</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">GetHeight</span>(t-&gt;Rchild) - <span class="built_in">GetHeight</span>(t-&gt;Lchild) == <span class="number">2</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(<span class="built_in">Compare</span>()(t-&gt;Rchild-&gt;data-&gt;first, val.first)) <span class="built_in">RR</span>(t);</span><br><span class="line">                    <span class="keyword">else</span> <span class="built_in">RL</span>(t);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">AdjustHeight</span>(t);</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">Adjust</span><span class="params">(Node *&amp;t, <span class="type">size_t</span> dir)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(dir == <span class="number">0</span>) <span class="comment">//LeftSubTree</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">GetHeight</span>(t-&gt;Rchild) - <span class="built_in">GetHeight</span>(t-&gt;Lchild) == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">GetHeight</span>(t-&gt;Lchild) == <span class="built_in">GetHeight</span>(t-&gt;Rchild)) &#123; --t-&gt;height; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">GetHeight</span>(t-&gt;Rchild-&gt;Lchild) &gt; <span class="built_in">GetHeight</span>(t-&gt;Rchild-&gt;Rchild)) &#123; <span class="built_in">RL</span>(t); <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">GetHeight</span>(t-&gt;Rchild-&gt;Lchild) &lt; <span class="built_in">GetHeight</span>(t-&gt;Rchild-&gt;Rchild)) &#123; <span class="built_in">RR</span>(t); <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">GetHeight</span>(t-&gt;Rchild-&gt;Lchild) == <span class="built_in">GetHeight</span>(t-&gt;Rchild-&gt;Rchild)) &#123; <span class="built_in">RR</span>(t); <span class="keyword">return</span> <span class="literal">true</span>; &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>         <span class="comment">//RightSubTree</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">GetHeight</span>(t-&gt;Lchild) - <span class="built_in">GetHeight</span>(t-&gt;Rchild) == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">GetHeight</span>(t-&gt;Lchild) == <span class="built_in">GetHeight</span>(t-&gt;Rchild)) &#123; --t-&gt;height; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">GetHeight</span>(t-&gt;Lchild-&gt;Rchild) &gt; <span class="built_in">GetHeight</span>(t-&gt;Lchild-&gt;Lchild)) &#123; <span class="built_in">LR</span>(t); <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">GetHeight</span>(t-&gt;Lchild-&gt;Rchild) &lt; <span class="built_in">GetHeight</span>(t-&gt;Lchild-&gt;Lchild)) &#123; <span class="built_in">LL</span>(t); <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">GetHeight</span>(t-&gt;Lchild-&gt;Rchild) == <span class="built_in">GetHeight</span>(t-&gt;Lchild-&gt;Lchild)) &#123; <span class="built_in">LL</span>(t); <span class="keyword">return</span> <span class="literal">true</span>; &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">Erase</span><span class="params">(<span class="type">const</span> Key &amp;target, Node *&amp;t)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(t == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">Equal</span>(target, t-&gt;data-&gt;first))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(t-&gt;Lchild == <span class="literal">nullptr</span> || t-&gt;Rchild == <span class="literal">nullptr</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    Node* tmp = t;</span><br><span class="line">                    t = (t-&gt;Lchild != <span class="literal">nullptr</span>) ? t-&gt;Lchild : t-&gt;Rchild;</span><br><span class="line">                    <span class="keyword">delete</span> tmp;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    Node *minR = t-&gt;Rchild, *minRfa = t;</span><br><span class="line">                    <span class="keyword">while</span>(minR-&gt;Lchild != <span class="literal">nullptr</span>) minRfa = minR, minR = minR-&gt;Lchild;</span><br><span class="line">                    Node* minRnew = <span class="keyword">new</span> <span class="built_in">Node</span>(*minR-&gt;data);</span><br><span class="line">                    minRnew-&gt;Lchild = minR-&gt;Lchild;</span><br><span class="line">                    minRnew-&gt;Rchild = minR-&gt;Rchild;</span><br><span class="line">                    minRnew-&gt;height = minR-&gt;height;</span><br><span class="line">                    <span class="keyword">if</span>(minRfa-&gt;Lchild == minR) minRfa-&gt;Lchild = minRnew;</span><br><span class="line">                    <span class="keyword">else</span> minRfa-&gt;Rchild = minRnew;</span><br><span class="line">                    minR-&gt;Lchild = t-&gt;Lchild;</span><br><span class="line">                    minR-&gt;Rchild = t-&gt;Rchild;</span><br><span class="line">                    minR-&gt;height = t-&gt;height;</span><br><span class="line">                    Node* del = t;</span><br><span class="line">                    t = minR;</span><br><span class="line">                    <span class="keyword">delete</span> del;</span><br><span class="line">                    <span class="keyword">if</span>(<span class="built_in">Erase</span>(t-&gt;data-&gt;first, t-&gt;Rchild)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">Adjust</span>(t, <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">Compare</span>()(target, t-&gt;data-&gt;first))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">Erase</span>(target, t-&gt;Lchild)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">Adjust</span>(t, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">Erase</span>(target, t-&gt;Rchild)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">Adjust</span>(t, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">Erase</span><span class="params">(<span class="type">const</span> Key &amp;target)</span> </span>&#123; --Size; <span class="built_in">Erase</span>(target, root); &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">Copy</span><span class="params">(Node *&amp;t, <span class="type">const</span> Node* other)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(other == <span class="literal">nullptr</span>) &#123; t = <span class="literal">nullptr</span>; <span class="keyword">return</span>; &#125;</span><br><span class="line">            t = <span class="keyword">new</span> <span class="built_in">Node</span>(*other-&gt;data);</span><br><span class="line">            t-&gt;height = other-&gt;height;</span><br><span class="line">            <span class="built_in">Copy</span>(t-&gt;Lchild, other-&gt;Lchild);</span><br><span class="line">            <span class="built_in">Copy</span>(t-&gt;Rchild, other-&gt;Rchild);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">Node* <span class="title">GetFirstNode</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> nil;</span><br><span class="line">            Node* t = root;</span><br><span class="line">            <span class="keyword">while</span>(t-&gt;Lchild != <span class="literal">nullptr</span>) t = t-&gt;Lchild;</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">Node* <span class="title">GetLastNode</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> nil;</span><br><span class="line">            Node* t = root;</span><br><span class="line">            <span class="keyword">while</span>(t-&gt;Rchild != <span class="literal">nullptr</span>) t = t-&gt;Rchild;</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">Node* <span class="title">GetPreNode</span><span class="params">(<span class="type">const</span> Key &amp;target, Node* t, Node *ret)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            Node *pos = t;</span><br><span class="line">            <span class="keyword">while</span>(<span class="built_in">Compare</span>()(pos-&gt;data-&gt;first, target))</span><br><span class="line">            &#123;</span><br><span class="line">                ret = pos;</span><br><span class="line">                pos = pos-&gt;Rchild;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">Equal</span>(pos-&gt;data-&gt;first, target))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(pos-&gt;Lchild)</span><br><span class="line">                &#123;</span><br><span class="line">                    ret = pos-&gt;Lchild;</span><br><span class="line">                    <span class="keyword">while</span>(ret-&gt;Rchild != <span class="literal">nullptr</span>) ret = ret-&gt;Rchild;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> ret = <span class="built_in">GetPreNode</span>(target, pos-&gt;Lchild, ret);</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">Node* <span class="title">GetNxtNode</span><span class="params">(<span class="type">const</span> Key &amp;target, Node* t, Node *ret)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            Node *pos = t;</span><br><span class="line">            <span class="keyword">while</span>(<span class="built_in">Compare</span>()(target, pos-&gt;data-&gt;first))</span><br><span class="line">            &#123;</span><br><span class="line">                ret = pos;</span><br><span class="line">                pos = pos-&gt;Lchild;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">Equal</span>(target, pos-&gt;data-&gt;first))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(pos-&gt;Rchild)</span><br><span class="line">                &#123;</span><br><span class="line">                    ret = pos-&gt;Rchild;</span><br><span class="line">                    <span class="keyword">while</span>(ret-&gt;Lchild != <span class="literal">nullptr</span>) ret = ret-&gt;Lchild;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> ret = <span class="built_in">GetNxtNode</span>(target, pos-&gt;Rchild, ret);</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">const_iterator</span>;</span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">iterator</span></span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">map</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line">            map* ptrmap;</span><br><span class="line">            Node* ptrNode;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            <span class="built_in">iterator</span>() &#123; ptrmap = <span class="literal">nullptr</span>, ptrNode = <span class="literal">nullptr</span>; &#125;</span><br><span class="line">            <span class="built_in">iterator</span>(map* _ptrmap, Node* _ptrNode) :<span class="built_in">ptrmap</span>(_ptrmap), <span class="built_in">ptrNode</span>(_ptrNode) &#123;&#125;</span><br><span class="line">            <span class="built_in">iterator</span>(<span class="type">const</span> iterator &amp;other) :<span class="built_in">ptrmap</span>(other.ptrmap), <span class="built_in">ptrNode</span>(other.ptrNode) &#123;&#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// iter++</span></span><br><span class="line">            iterator <span class="keyword">operator</span>++(<span class="type">int</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(ptrmap == <span class="literal">nullptr</span> || ptrNode == ptrmap-&gt;nil)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="built_in">invalid_iterator</span>();</span><br><span class="line">                iterator ret = *<span class="keyword">this</span>;</span><br><span class="line">                ptrNode = ptrmap-&gt;<span class="built_in">GetNxtNode</span>(ptrNode-&gt;data-&gt;first, ptrmap-&gt;root, ptrmap-&gt;nil);</span><br><span class="line">                <span class="keyword">return</span> ret;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// ++iter</span></span><br><span class="line">            iterator &amp; <span class="keyword">operator</span>++()</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(ptrmap == <span class="literal">nullptr</span> || ptrNode == ptrmap-&gt;nil)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="built_in">invalid_iterator</span>();</span><br><span class="line">                ptrNode = ptrmap-&gt;<span class="built_in">GetNxtNode</span>(ptrNode-&gt;data-&gt;first, ptrmap-&gt;root, ptrmap-&gt;nil);</span><br><span class="line">                <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// iter--</span></span><br><span class="line">            iterator <span class="keyword">operator</span>--(<span class="type">int</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(ptrmap == <span class="literal">nullptr</span> || *<span class="keyword">this</span> == ptrmap-&gt;<span class="built_in">begin</span>())</span><br><span class="line">                    <span class="keyword">throw</span> <span class="built_in">invalid_iterator</span>();</span><br><span class="line">                iterator ret = *<span class="keyword">this</span>;</span><br><span class="line">                <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;ptrNode == ptrmap-&gt;nil) ptrNode = ptrmap-&gt;<span class="built_in">GetLastNode</span>();</span><br><span class="line">                <span class="keyword">else</span> ptrNode = ptrmap-&gt;<span class="built_in">GetPreNode</span>(ptrNode-&gt;data-&gt;first, ptrmap-&gt;root, ptrmap-&gt;nil);</span><br><span class="line">                <span class="keyword">return</span> ret;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// --iter</span></span><br><span class="line">            iterator &amp; <span class="keyword">operator</span>--()</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(ptrmap == <span class="literal">nullptr</span> || *<span class="keyword">this</span> == ptrmap-&gt;<span class="built_in">begin</span>())</span><br><span class="line">                    <span class="keyword">throw</span> <span class="built_in">invalid_iterator</span>();</span><br><span class="line">                <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;ptrNode == ptrmap-&gt;nil) ptrNode = ptrmap-&gt;<span class="built_in">GetLastNode</span>();</span><br><span class="line">                <span class="keyword">else</span> ptrNode = ptrmap-&gt;<span class="built_in">GetPreNode</span>(ptrNode-&gt;data-&gt;first, ptrmap-&gt;root, ptrmap-&gt;nil);</span><br><span class="line">                <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            value_type &amp; <span class="keyword">operator</span>*() <span class="type">const</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(ptrmap == <span class="literal">nullptr</span> || ptrNode == ptrmap-&gt;nil)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="built_in">invalid_iterator</span>();</span><br><span class="line">                <span class="keyword">return</span> *ptrNode-&gt;data;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            value_type* <span class="keyword">operator</span>-&gt;() <span class="type">const</span> <span class="keyword">noexcept</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(ptrmap == <span class="literal">nullptr</span> || ptrNode == ptrmap-&gt;nil)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="built_in">invalid_iterator</span>();</span><br><span class="line">                <span class="keyword">return</span> ptrNode-&gt;data;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> iterator &amp;rhs) <span class="type">const</span> &#123; <span class="keyword">return</span> ptrmap == rhs.ptrmap &amp;&amp; ptrNode == rhs.ptrNode; &#125;</span><br><span class="line">            <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> const_iterator &amp;rhs) <span class="type">const</span> &#123; <span class="keyword">return</span> ptrmap == rhs.ptrmap &amp;&amp; ptrNode == rhs.ptrNode; &#125;</span><br><span class="line">            <span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> iterator &amp;rhs) <span class="type">const</span> &#123; <span class="keyword">return</span> ptrmap != rhs.ptrmap || ptrNode != rhs.ptrNode; &#125;</span><br><span class="line">            <span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> const_iterator &amp;rhs) <span class="type">const</span> &#123; <span class="keyword">return</span> ptrmap != rhs.ptrmap || ptrNode != rhs.ptrNode; &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">const_iterator</span></span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">map</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line">            <span class="type">const</span> map* ptrmap;</span><br><span class="line">            Node* ptrNode;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            <span class="built_in">const_iterator</span>() :<span class="built_in">ptrmap</span>(<span class="literal">nullptr</span>), <span class="built_in">ptrNode</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">            <span class="built_in">const_iterator</span>(<span class="type">const</span> map* _ptrmap, Node* _ptrNode) :<span class="built_in">ptrmap</span>(_ptrmap), <span class="built_in">ptrNode</span>(_ptrNode) &#123;&#125;</span><br><span class="line">            <span class="built_in">const_iterator</span>(<span class="type">const</span> const_iterator &amp;other) :<span class="built_in">ptrmap</span>(other.ptrmap), <span class="built_in">ptrNode</span>(other.ptrNode) &#123;&#125;</span><br><span class="line">            <span class="built_in">const_iterator</span>(<span class="type">const</span> iterator &amp;other) :<span class="built_in">ptrmap</span>(other.ptrmap), <span class="built_in">ptrNode</span>(other.ptrNode) &#123;&#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// iter++</span></span><br><span class="line">            const_iterator <span class="keyword">operator</span>++(<span class="type">int</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(ptrmap == <span class="literal">nullptr</span> || ptrNode == ptrmap-&gt;nil)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="built_in">invalid_iterator</span>();</span><br><span class="line">                const_iterator ret = *<span class="keyword">this</span>;</span><br><span class="line">                ptrNode = ptrmap-&gt;<span class="built_in">GetNxtNode</span>(ptrNode-&gt;data-&gt;first, ptrmap-&gt;root, ptrmap-&gt;nil);</span><br><span class="line">                <span class="keyword">return</span> ret;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// ++iter</span></span><br><span class="line">            const_iterator &amp; <span class="keyword">operator</span>++()</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(ptrmap == <span class="literal">nullptr</span> || ptrNode == ptrmap-&gt;nil)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="built_in">invalid_iterator</span>();</span><br><span class="line">                ptrNode = ptrmap-&gt;<span class="built_in">GetNxtNode</span>(ptrNode-&gt;data-&gt;first, ptrmap-&gt;root, ptrmap-&gt;nil);</span><br><span class="line">                <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// iter--</span></span><br><span class="line">            const_iterator <span class="keyword">operator</span>--(<span class="type">int</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(ptrmap == <span class="literal">nullptr</span> || *<span class="keyword">this</span> == ptrmap-&gt;<span class="built_in">cbegin</span>())</span><br><span class="line">                    <span class="keyword">throw</span> <span class="built_in">invalid_iterator</span>();</span><br><span class="line">                const_iterator ret = *<span class="keyword">this</span>;</span><br><span class="line">                <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;ptrNode == ptrmap-&gt;nil) ptrNode = ptrmap-&gt;<span class="built_in">GetLastNode</span>();</span><br><span class="line">                <span class="keyword">else</span> ptrNode = ptrmap-&gt;<span class="built_in">GetPreNode</span>(ptrNode-&gt;data-&gt;first, ptrmap-&gt;root, ptrmap-&gt;nil);</span><br><span class="line">                <span class="keyword">return</span> ret;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// --iter</span></span><br><span class="line">            const_iterator &amp; <span class="keyword">operator</span>--()</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(ptrmap == <span class="literal">nullptr</span> || *<span class="keyword">this</span> == ptrmap-&gt;<span class="built_in">cbegin</span>())</span><br><span class="line">                    <span class="keyword">throw</span> <span class="built_in">invalid_iterator</span>();</span><br><span class="line">                <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;ptrNode == ptrmap-&gt;nil) ptrNode = ptrmap-&gt;<span class="built_in">GetLastNode</span>();</span><br><span class="line">                <span class="keyword">else</span> ptrNode = ptrmap-&gt;<span class="built_in">GetPreNode</span>(ptrNode-&gt;data-&gt;first, ptrmap-&gt;root, ptrmap-&gt;nil);</span><br><span class="line">                <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            value_type &amp; <span class="keyword">operator</span>*() <span class="type">const</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(ptrmap == <span class="literal">nullptr</span> || ptrNode == ptrmap-&gt;nil)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="built_in">invalid_iterator</span>();</span><br><span class="line">                <span class="keyword">return</span> *ptrNode-&gt;data;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            value_type* <span class="keyword">operator</span>-&gt;() <span class="type">const</span> <span class="keyword">noexcept</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(ptrmap == <span class="literal">nullptr</span> || ptrNode == ptrmap-&gt;nil)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="built_in">invalid_iterator</span>();</span><br><span class="line">                <span class="keyword">return</span> ptrNode-&gt;data;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> iterator &amp;rhs) <span class="type">const</span> &#123; <span class="keyword">return</span> ptrmap == rhs.ptrmap &amp;&amp; ptrNode == rhs.ptrNode; &#125;</span><br><span class="line">            <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> const_iterator &amp;rhs) <span class="type">const</span> &#123; <span class="keyword">return</span> ptrmap == rhs.ptrmap &amp;&amp; ptrNode == rhs.ptrNode; &#125;</span><br><span class="line">            <span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> iterator &amp;rhs) <span class="type">const</span> &#123; <span class="keyword">return</span> ptrmap != rhs.ptrmap || ptrNode != rhs.ptrNode; &#125;</span><br><span class="line">            <span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> const_iterator &amp;rhs) <span class="type">const</span> &#123; <span class="keyword">return</span> ptrmap != rhs.ptrmap || ptrNode != rhs.ptrNode; &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">map</span>() :<span class="built_in">Size</span>(<span class="number">0</span>) &#123; root = <span class="literal">nullptr</span>, nil = <span class="keyword">new</span> <span class="built_in">Node</span>(); &#125;</span><br><span class="line">        <span class="built_in">map</span>(<span class="type">const</span> map &amp;other) :<span class="built_in">Size</span>(other.Size)</span><br><span class="line">        &#123;</span><br><span class="line">            nil = <span class="keyword">new</span> <span class="built_in">Node</span>();</span><br><span class="line">            <span class="built_in">Copy</span>(root, other.root);</span><br><span class="line">        &#125;</span><br><span class="line">        map &amp; <span class="keyword">operator</span>=(<span class="type">const</span> map &amp;other)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span> == &amp;other) <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">            <span class="built_in">Clear</span>(root);</span><br><span class="line">            Size = other.Size;</span><br><span class="line">            <span class="built_in">Copy</span>(root, other.root);</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ~<span class="built_in">map</span>() &#123; <span class="built_in">clear</span>(); <span class="keyword">delete</span> nil; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">T &amp; <span class="title">at</span><span class="params">(<span class="type">const</span> Key &amp;key)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            Node* pos = <span class="built_in">Find</span>(key, root);</span><br><span class="line">            <span class="keyword">if</span>(pos == nil)</span><br><span class="line">                <span class="keyword">throw</span> <span class="built_in">index_out_of_bound</span>();</span><br><span class="line">            <span class="keyword">return</span> pos-&gt;data-&gt;second;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">const</span> T &amp; <span class="title">at</span><span class="params">(<span class="type">const</span> Key &amp;key)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            Node* pos = <span class="built_in">Find</span>(key, root);</span><br><span class="line">            <span class="keyword">if</span>(pos == nil)</span><br><span class="line">                <span class="keyword">throw</span> <span class="built_in">index_out_of_bound</span>();</span><br><span class="line">            <span class="keyword">return</span> pos-&gt;data-&gt;second;</span><br><span class="line">        &#125;</span><br><span class="line">        T &amp; <span class="keyword">operator</span>[](<span class="type">const</span> Key &amp;key)</span><br><span class="line">        &#123;</span><br><span class="line">            Node* pos = <span class="built_in">Find</span>(key, root);</span><br><span class="line">            <span class="keyword">if</span>(pos == nil)</span><br><span class="line">            &#123;</span><br><span class="line">                ++Size;</span><br><span class="line">                pos = <span class="built_in">Insert</span>(<span class="built_in">value_type</span>(key, <span class="built_in">T</span>()), root);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> pos-&gt;data-&gt;second;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">const</span> T &amp; <span class="keyword">operator</span>[](<span class="type">const</span> Key &amp;key) <span class="type">const</span></span><br><span class="line">        &#123;</span><br><span class="line">            Node* pos = <span class="built_in">Find</span>(key, root);</span><br><span class="line">            <span class="keyword">if</span>(pos == nil)</span><br><span class="line">                <span class="keyword">throw</span> <span class="built_in">index_out_of_bound</span>();</span><br><span class="line">            <span class="keyword">return</span> pos-&gt;data-&gt;second;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">iterator</span>(<span class="keyword">this</span>, <span class="built_in">GetFirstNode</span>()); &#125;</span><br><span class="line">        <span class="function">const_iterator <span class="title">cbegin</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">const_iterator</span>(<span class="keyword">this</span>, <span class="built_in">GetFirstNode</span>()); &#125;</span><br><span class="line">        <span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">iterator</span>(<span class="keyword">this</span>, nil); &#125;</span><br><span class="line">        <span class="function">const_iterator <span class="title">cend</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">const_iterator</span>(<span class="keyword">this</span>, nil); &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> Size == <span class="number">0</span>; &#125;</span><br><span class="line">        <span class="function"><span class="type">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> Size; &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123; <span class="built_in">Clear</span>(root); Size = <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">pair&lt;iterator, <span class="type">bool</span>&gt; <span class="title">insert</span><span class="params">(<span class="type">const</span> value_type &amp;value)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            Node* pos = <span class="built_in">Find</span>(value.first);</span><br><span class="line">            <span class="keyword">if</span>(pos == nil)</span><br><span class="line">            &#123;</span><br><span class="line">                ++Size;</span><br><span class="line">                pos = <span class="built_in">Insert</span>(value, root);</span><br><span class="line">                <span class="function">iterator <span class="title">iter</span><span class="params">(<span class="keyword">this</span>, pos)</span></span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">pair</span>&lt;iterator, <span class="type">bool</span>&gt;(iter, <span class="literal">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                iterator <span class="built_in">iter</span>(<span class="keyword">this</span>, pos);</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">pair</span>&lt;iterator, <span class="type">bool</span>&gt;(iter, <span class="literal">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">erase</span><span class="params">(iterator pos)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(pos.ptrmap != <span class="keyword">this</span> || pos.ptrNode == nil)</span><br><span class="line">                <span class="keyword">throw</span> <span class="built_in">invalid_iterator</span>();</span><br><span class="line">            <span class="built_in">Erase</span>(pos.ptrNode-&gt;data-&gt;first);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">size_t</span> <span class="title">count</span><span class="params">(<span class="type">const</span> Key &amp;key)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">Find</span>(key, root) != nil) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">iterator <span class="title">find</span><span class="params">(<span class="type">const</span> Key &amp;key)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            Node* pos = <span class="built_in">Find</span>(key, root);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">iterator</span>(<span class="keyword">this</span>, pos);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">const_iterator <span class="title">find</span><span class="params">(<span class="type">const</span> Key &amp;key)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            Node* pos = <span class="built_in">Find</span>(key, root);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">const_iterator</span>(<span class="keyword">this</span>, pos);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125; <span class="comment">// namespace sjtu</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//SJTU_MAP_HPP</span></span></span><br></pre></td></tr></table></figure>
<hr>
<h1 id="b-tree">B+ Tree</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Finished by MeteorVanish on 2022.6.19</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SJTU_BPLUSTREE_HPP</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SJTU_BPLUSTREE_HPP</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstddef&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;exception.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::pair;</span><br><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"><span class="keyword">using</span> std::fstream;</span><br><span class="line"><span class="keyword">using</span> std::ifstream;</span><br><span class="line"><span class="keyword">using</span> std::ofstream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">TYPE</span> &#123;INTERNAL = <span class="number">73</span><span class="comment">/*I*/</span>, LEAF = <span class="number">76</span><span class="comment">/*L*/</span>, NIL = <span class="number">78</span><span class="comment">/*N*/</span>, EMPTY = <span class="number">69</span><span class="comment">/*E*/</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">size_t</span> ORDER = <span class="number">10</span>;          <span class="comment">// max Child num of INTERNAL Node</span></span><br><span class="line"><span class="type">const</span> <span class="type">size_t</span> CAPACITY_LEAF = <span class="number">100</span>; <span class="comment">// max Data num of LEAF Node</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> sjtu</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Key</span>, <span class="keyword">class</span> <span class="title class_">Value</span>&gt;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">BPlusTree</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">using</span> DataType = pair&lt;Key, Value&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span> *FileName;</span><br><span class="line">        <span class="type">size_t</span> FileFlag;</span><br><span class="line">        fstream File;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">size_t</span> Type;                      <span class="comment">// INTERNAL or LEAF or NIL</span></span><br><span class="line">            <span class="type">size_t</span> Num;                       <span class="comment">// max: MAX_CHILD - 1</span></span><br><span class="line">            <span class="type">size_t</span> FatherIndex;</span><br><span class="line">            <span class="type">size_t</span> ChildIndex[ORDER + <span class="number">1</span>];     <span class="comment">// 0 ~ Num (one extra space for overflow, only for INTERNAL Node)</span></span><br><span class="line">            Key KeyIndex[ORDER + <span class="number">1</span>];          <span class="comment">// 1 ~ Num (one extra space for overflow, only for INTERNAL Node)</span></span><br><span class="line">            DataType Data[CAPACITY_LEAF + <span class="number">2</span>]; <span class="comment">// 1 ~ Num (one extra space for overflow, only for LEAF Node)</span></span><br><span class="line">            <span class="type">size_t</span> PrevLeafIndex;             <span class="comment">// only for LEAF Node</span></span><br><span class="line">            <span class="type">size_t</span> NextLeafIndex;             <span class="comment">// only for LEAF Node</span></span><br><span class="line">            <span class="type">size_t</span> NextEmptyIndex;            <span class="comment">// only for space recovery</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">Node</span>() = <span class="keyword">default</span>;</span><br><span class="line">            <span class="built_in">Node</span>(TYPE Type_param)</span><br><span class="line">                :<span class="built_in">Type</span>(Type_param), <span class="built_in">Num</span>(<span class="number">0</span>), <span class="built_in">NextEmptyIndex</span>(<span class="number">-1</span>), <span class="built_in">FatherIndex</span>(<span class="number">-1</span>), <span class="built_in">PrevLeafIndex</span>(<span class="number">-1</span>), <span class="built_in">NextLeafIndex</span>(<span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">memset</span>(ChildIndex, <span class="number">0</span>, <span class="built_in">sizeof</span>(ChildIndex));</span><br><span class="line">                <span class="built_in">memset</span>(KeyIndex, <span class="number">0</span>, <span class="built_in">sizeof</span>(KeyIndex));</span><br><span class="line">                <span class="built_in">memset</span>(Data, <span class="number">0</span>, <span class="built_in">sizeof</span>(Data));</span><br><span class="line">            &#125;</span><br><span class="line">            ~<span class="built_in">Node</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// insert InsertData to Data[] while keeping ascending order</span></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">LeafInsert</span><span class="params">(DataType InsertData)</span></span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                Data[++Num] = InsertData;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">size_t</span> i = Num; i &gt;= <span class="number">1</span>; --i)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(i != <span class="number">1</span> &amp;&amp; InsertData.first &lt; Data[i - <span class="number">1</span>].first)</span><br><span class="line">                        Data[i] = Data[i - <span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">else</span> &#123; Data[i] = InsertData; <span class="keyword">break</span>; &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// insert InsertKey and NewNodeIndex while keeping KeyIndex[]&#x27;s ascending order</span></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">InternalInsert</span><span class="params">(Key InsertKey, <span class="type">size_t</span> NewNodeIndex)</span></span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                ++Num;</span><br><span class="line">                KeyIndex[Num] = InsertKey;</span><br><span class="line">                ChildIndex[Num] = NewNodeIndex;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">size_t</span> i = Num; i &gt;= <span class="number">1</span>; --i)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(i != <span class="number">1</span> &amp;&amp; InsertKey &lt; KeyIndex[i - <span class="number">1</span>])</span><br><span class="line">                    &#123;</span><br><span class="line">                        KeyIndex[i] = KeyIndex[i - <span class="number">1</span>];</span><br><span class="line">                        ChildIndex[i] = ChildIndex[i - <span class="number">1</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        KeyIndex[i] = InsertKey;</span><br><span class="line">                        ChildIndex[i] = NewNodeIndex;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// erase Data whose first == EraseKey in Data[]</span></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">LeafErase</span><span class="params">(Key EraseKey)</span></span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                <span class="type">size_t</span> EraseIndex;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">1</span>; i &lt;= Num; ++i)</span><br><span class="line">                    <span class="keyword">if</span>(Data[i].first == EraseKey)</span><br><span class="line">                    &#123; EraseIndex = i; <span class="keyword">break</span>;&#125;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">size_t</span> i = EraseIndex; i &lt;= Num - <span class="number">1</span>; ++i)</span><br><span class="line">                    Data[i] = Data[i + <span class="number">1</span>];</span><br><span class="line">                Data[Num--] = <span class="built_in">DataType</span>();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// erase EraseKey and corresponding ChildIndex</span></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">InternalErase</span><span class="params">(Key EraseKey)</span></span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                <span class="type">size_t</span> EraseIndex = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">1</span>; i &lt;= Num; ++i)</span><br><span class="line">                    <span class="keyword">if</span>(KeyIndex[i] == EraseKey)</span><br><span class="line">                    &#123; EraseIndex = i; <span class="keyword">break</span>;&#125;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">size_t</span> i = EraseIndex; i &lt;= Num - <span class="number">1</span>; ++i)</span><br><span class="line">                    KeyIndex[i] = KeyIndex[i + <span class="number">1</span>], ChildIndex[i] = ChildIndex[i + <span class="number">1</span>];</span><br><span class="line">                KeyIndex[<span class="number">0</span>] = <span class="built_in">Key</span>();</span><br><span class="line">                KeyIndex[Num] = <span class="built_in">Key</span>();</span><br><span class="line">                ChildIndex[Num] = <span class="built_in">size_t</span>();</span><br><span class="line">                --Num;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">Reset</span><span class="params">()</span></span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                Type = EMPTY;</span><br><span class="line">                Num = <span class="number">0</span>;</span><br><span class="line">                FatherIndex = <span class="number">-1</span>;</span><br><span class="line">                PrevLeafIndex = <span class="number">-1</span>;</span><br><span class="line">                NextLeafIndex = <span class="number">-1</span>;</span><br><span class="line">                <span class="built_in">memset</span>(ChildIndex, <span class="number">0</span>, <span class="built_in">sizeof</span>(ChildIndex));</span><br><span class="line">                <span class="built_in">memset</span>(KeyIndex, <span class="number">0</span>, <span class="built_in">sizeof</span>(KeyIndex));</span><br><span class="line">                <span class="built_in">memset</span>(Data, <span class="number">0</span>, <span class="built_in">sizeof</span>(Data));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// to avoid opening file multiple times</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">OpenFile</span><span class="params">()</span> </span>&#123; <span class="keyword">if</span>(FileFlag++ == <span class="number">0</span>) File.<span class="built_in">open</span>(FileName); &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// to avoid closing file multiple times</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">CloseFile</span><span class="params">()</span> </span>&#123; <span class="keyword">if</span>(FileFlag-- == <span class="number">1</span>) File.<span class="built_in">close</span>(); &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">size_t</span> <span class="title">GetSize</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="built_in">OpenFile</span>();</span><br><span class="line">            <span class="type">size_t</span> Size;</span><br><span class="line">            File.<span class="built_in">seekg</span>(<span class="number">0</span>);</span><br><span class="line">            File.<span class="built_in">read</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(&amp;Size), <span class="built_in">sizeof</span>(<span class="type">size_t</span>));</span><br><span class="line">            <span class="built_in">CloseFile</span>();</span><br><span class="line">            <span class="keyword">return</span> Size;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">PutSize</span><span class="params">(<span class="type">size_t</span> Size)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="built_in">OpenFile</span>();</span><br><span class="line">            File.<span class="built_in">seekp</span>(<span class="number">0</span>);</span><br><span class="line">            File.<span class="built_in">write</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(&amp;Size), <span class="built_in">sizeof</span>(<span class="type">size_t</span>));</span><br><span class="line">            <span class="built_in">CloseFile</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">size_t</span> <span class="title">GetNodeMaxIndex</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="built_in">OpenFile</span>();</span><br><span class="line">            <span class="type">size_t</span> NodeMaxIndex;</span><br><span class="line">            File.<span class="built_in">seekg</span>(<span class="built_in">sizeof</span>(<span class="type">size_t</span>));</span><br><span class="line">            File.<span class="built_in">read</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(&amp;NodeMaxIndex), <span class="built_in">sizeof</span>(<span class="type">size_t</span>));</span><br><span class="line">            <span class="built_in">CloseFile</span>();</span><br><span class="line">            <span class="keyword">return</span> NodeMaxIndex;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">PutNodeMaxIndex</span><span class="params">(<span class="type">size_t</span> NodeMaxIndex)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="built_in">OpenFile</span>();</span><br><span class="line">            File.<span class="built_in">seekp</span>(<span class="built_in">sizeof</span>(<span class="type">size_t</span>));</span><br><span class="line">            File.<span class="built_in">write</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(&amp;NodeMaxIndex), <span class="built_in">sizeof</span>(<span class="type">size_t</span>));</span><br><span class="line">            <span class="built_in">CloseFile</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="type">size_t</span> <span class="title">GetRootIndex</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="built_in">OpenFile</span>();</span><br><span class="line">            <span class="type">size_t</span> RootIndex;</span><br><span class="line">            File.<span class="built_in">seekg</span>(<span class="number">2</span> * <span class="built_in">sizeof</span>(<span class="type">size_t</span>));</span><br><span class="line">            File.<span class="built_in">read</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(&amp;RootIndex), <span class="built_in">sizeof</span>(<span class="type">size_t</span>));</span><br><span class="line">            <span class="built_in">CloseFile</span>();</span><br><span class="line">            <span class="keyword">return</span> RootIndex;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">PutRootIndex</span><span class="params">(<span class="type">size_t</span> RootIndex)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="built_in">OpenFile</span>();</span><br><span class="line">            File.<span class="built_in">seekp</span>(<span class="number">2</span> * <span class="built_in">sizeof</span>(<span class="type">size_t</span>));</span><br><span class="line">            File.<span class="built_in">write</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(&amp;RootIndex), <span class="built_in">sizeof</span>(<span class="type">size_t</span>));</span><br><span class="line">            <span class="built_in">CloseFile</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">size_t</span> <span class="title">GetEmptyIndex</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="built_in">OpenFile</span>();</span><br><span class="line">            <span class="type">size_t</span> EmptyIndex;</span><br><span class="line">            File.<span class="built_in">seekg</span>(<span class="number">3</span> * <span class="built_in">sizeof</span>(<span class="type">size_t</span>));</span><br><span class="line">            File.<span class="built_in">read</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(&amp;EmptyIndex), <span class="built_in">sizeof</span>(<span class="type">size_t</span>));</span><br><span class="line">            <span class="built_in">CloseFile</span>();</span><br><span class="line">            <span class="keyword">return</span> EmptyIndex;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">PutEmptyIndex</span><span class="params">(<span class="type">size_t</span> EmptyIndex)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="built_in">OpenFile</span>();</span><br><span class="line">            File.<span class="built_in">seekp</span>(<span class="number">3</span> * <span class="built_in">sizeof</span>(<span class="type">size_t</span>));</span><br><span class="line">            File.<span class="built_in">write</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(&amp;EmptyIndex), <span class="built_in">sizeof</span>(<span class="type">size_t</span>));</span><br><span class="line">            <span class="built_in">CloseFile</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// return the Address corresponding to the Index</span></span><br><span class="line">        <span class="function"><span class="type">size_t</span> <span class="title">GetNodeAddress</span><span class="params">(<span class="type">size_t</span> Index)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(Index == <span class="number">-2</span>) <span class="comment">// Head</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">4</span> * <span class="built_in">sizeof</span>(<span class="type">size_t</span>);</span><br><span class="line">            <span class="keyword">if</span>(Index == <span class="number">-3</span>) <span class="comment">// Tail</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">4</span> * <span class="built_in">sizeof</span>(<span class="type">size_t</span>) + <span class="built_in">sizeof</span>(Node);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">4</span> * <span class="built_in">sizeof</span>(<span class="type">size_t</span>) + (Index + <span class="number">2</span>) * <span class="built_in">sizeof</span>(Node);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// return Index of new Node (with space recovery)</span></span><br><span class="line">        <span class="function"><span class="type">size_t</span> <span class="title">NewNodeIndex</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="built_in">OpenFile</span>();</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">GetEmptyIndex</span>() == <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">PutNodeMaxIndex</span>(<span class="built_in">GetNodeMaxIndex</span>() + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">GetNodeMaxIndex</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">// space recovery</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">OpenFile</span>();</span><br><span class="line">                <span class="type">size_t</span> Index = <span class="built_in">GetEmptyIndex</span>();</span><br><span class="line">                Node Pos;</span><br><span class="line">                File.<span class="built_in">seekg</span>(<span class="built_in">GetNodeAddress</span>(Index));</span><br><span class="line">                File.<span class="built_in">read</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(&amp;Pos), <span class="built_in">sizeof</span>(Node));</span><br><span class="line">                <span class="built_in">PutEmptyIndex</span>(Pos.NextEmptyIndex);</span><br><span class="line">                <span class="built_in">CloseFile</span>();</span><br><span class="line">                <span class="keyword">return</span> Index;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">CloseFile</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// return Index of the target&#x27;s LEAF Node</span></span><br><span class="line">        <span class="function"><span class="type">size_t</span> <span class="title">FindLeaf</span><span class="params">(<span class="type">const</span> Key &amp;target)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="built_in">OpenFile</span>();</span><br><span class="line">            <span class="type">size_t</span> TargetIndex = <span class="built_in">GetRootIndex</span>();</span><br><span class="line">            Node Pos;</span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                File.<span class="built_in">seekg</span>(<span class="built_in">GetNodeAddress</span>(TargetIndex));</span><br><span class="line">                File.<span class="built_in">read</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(&amp;Pos), <span class="built_in">sizeof</span>(Node));</span><br><span class="line">                <span class="keyword">if</span>(Pos.Type == LEAF) <span class="keyword">break</span>; <span class="comment">// root is LEAF</span></span><br><span class="line">                TargetIndex = Pos.ChildIndex[Pos.Num];</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">1</span>; i &lt;= Pos.Num; ++i)</span><br><span class="line">                    <span class="keyword">if</span>(target &lt; Pos.KeyIndex[i])</span><br><span class="line">                        &#123; TargetIndex = Pos.ChildIndex[i - <span class="number">1</span>]; <span class="keyword">break</span>; &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">CloseFile</span>();</span><br><span class="line">            <span class="keyword">return</span> TargetIndex;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// return the Node corresponding to NodeIndex in the iterator</span></span><br><span class="line">        <span class="function">Node <span class="title">IterGetNode</span><span class="params">(<span class="type">size_t</span> NodeIndex)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="built_in">OpenFile</span>();</span><br><span class="line">            Node ret;</span><br><span class="line">            File.<span class="built_in">seekg</span>(<span class="built_in">GetNodeAddress</span>(NodeIndex));</span><br><span class="line">            File.<span class="built_in">read</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(&amp;ret), <span class="built_in">sizeof</span>(Node));</span><br><span class="line">            <span class="built_in">CloseFile</span>();</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// write Pos to file</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">IterPutNode</span><span class="params">(Node Pos, <span class="type">size_t</span> NodeIndex)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="built_in">OpenFile</span>();</span><br><span class="line">            File.<span class="built_in">seekp</span>(<span class="built_in">GetNodeAddress</span>(NodeIndex));</span><br><span class="line">            File.<span class="built_in">write</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(&amp;Pos), <span class="built_in">sizeof</span>(Node));</span><br><span class="line">            <span class="built_in">CloseFile</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">// write content at the head of file</span></span><br><span class="line">        <span class="comment">// content: Size(size_t), NodeMaxIndex(size_t), RootIndex(size_t), EmptyIndex(size_t), Head(Node), Tail(Node)</span></span><br><span class="line">        <span class="built_in">BPlusTree</span>(<span class="type">const</span> <span class="type">char</span>* FileName_param = <span class="string">&quot;DataFile.txt&quot;</span>) :<span class="built_in">FileName</span>(FileName_param), <span class="built_in">FileFlag</span>(<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">OpenFile</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// write init data</span></span><br><span class="line">            <span class="type">size_t</span> Size = <span class="number">0</span>, NodeMaxIndex = <span class="number">0</span>, RootIndex = <span class="number">0</span>, EmptyIndex = <span class="number">-1</span>;</span><br><span class="line">            <span class="function">Node <span class="title">Root</span><span class="params">(LEAF)</span>, <span class="title">Head</span><span class="params">(NIL)</span>, <span class="title">Tail</span><span class="params">(NIL)</span></span>;</span><br><span class="line">            Head.NextLeafIndex = RootIndex;</span><br><span class="line">            Tail.PrevLeafIndex = RootIndex;</span><br><span class="line">            Root.PrevLeafIndex = <span class="number">-2</span>; <span class="comment">// HeadIndex = -2</span></span><br><span class="line">            Root.NextLeafIndex = <span class="number">-3</span>; <span class="comment">// TailIndex = -3</span></span><br><span class="line">            File.<span class="built_in">seekp</span>(<span class="number">0</span>);</span><br><span class="line">            File.<span class="built_in">write</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(&amp;Size), <span class="built_in">sizeof</span>(<span class="type">size_t</span>));</span><br><span class="line">            File.<span class="built_in">write</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(&amp;NodeMaxIndex), <span class="built_in">sizeof</span>(<span class="type">size_t</span>));</span><br><span class="line">            File.<span class="built_in">write</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(&amp;RootIndex), <span class="built_in">sizeof</span>(<span class="type">size_t</span>));</span><br><span class="line">            File.<span class="built_in">write</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(&amp;EmptyIndex), <span class="built_in">sizeof</span>(<span class="type">size_t</span>));</span><br><span class="line">            File.<span class="built_in">write</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(&amp;Head), <span class="built_in">sizeof</span>(Node));</span><br><span class="line">            File.<span class="built_in">write</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(&amp;Tail), <span class="built_in">sizeof</span>(Node));</span><br><span class="line">            File.<span class="built_in">write</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(&amp;Root), <span class="built_in">sizeof</span>(Node));</span><br><span class="line"></span><br><span class="line">            <span class="built_in">CloseFile</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ~<span class="built_in">BPlusTree</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// clear the BPlusTree</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="comment">// clear the file</span></span><br><span class="line">            <span class="function">fstream <span class="title">ClearFile</span><span class="params">(FileName, std::ios::out | std::ios::trunc)</span></span>;</span><br><span class="line">            ClearFile.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// rewrite init data</span></span><br><span class="line">            <span class="built_in">OpenFile</span>();</span><br><span class="line">            <span class="type">size_t</span> Size = <span class="number">0</span>, NodeMaxIndex = <span class="number">0</span>, RootIndex = <span class="number">0</span>, EmptyIndex = <span class="number">-1</span>;</span><br><span class="line">            <span class="function">Node <span class="title">Root</span><span class="params">(LEAF)</span>, <span class="title">Head</span><span class="params">(NIL)</span>, <span class="title">Tail</span><span class="params">(NIL)</span></span>;</span><br><span class="line">            Head.NextLeafIndex = RootIndex;</span><br><span class="line">            Tail.PrevLeafIndex = RootIndex;</span><br><span class="line">            Root.PrevLeafIndex = <span class="number">-2</span>; <span class="comment">// HeadIndex = -2</span></span><br><span class="line">            Root.NextLeafIndex = <span class="number">-3</span>; <span class="comment">// TailIndex = -3</span></span><br><span class="line">            File.<span class="built_in">seekp</span>(<span class="number">0</span>);</span><br><span class="line">            File.<span class="built_in">write</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(&amp;Size), <span class="built_in">sizeof</span>(<span class="type">size_t</span>));</span><br><span class="line">            File.<span class="built_in">write</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(&amp;NodeMaxIndex), <span class="built_in">sizeof</span>(<span class="type">size_t</span>));</span><br><span class="line">            File.<span class="built_in">write</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(&amp;RootIndex), <span class="built_in">sizeof</span>(<span class="type">size_t</span>));</span><br><span class="line">            File.<span class="built_in">write</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(&amp;EmptyIndex), <span class="built_in">sizeof</span>(<span class="type">size_t</span>));</span><br><span class="line">            File.<span class="built_in">write</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(&amp;Head), <span class="built_in">sizeof</span>(Node));</span><br><span class="line">            File.<span class="built_in">write</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(&amp;Tail), <span class="built_in">sizeof</span>(Node));</span><br><span class="line">            File.<span class="built_in">write</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(&amp;Root), <span class="built_in">sizeof</span>(Node));</span><br><span class="line">            <span class="built_in">CloseFile</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// return true if insert successfully, else return false</span></span><br><span class="line">        <span class="comment">// do nothing if key already exists</span></span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">insert</span><span class="params">(<span class="type">const</span> Key &amp;key, <span class="type">const</span> Value &amp;value)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="built_in">OpenFile</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// insert &lt;key, value&gt; to Leaf</span></span><br><span class="line">            <span class="type">size_t</span> LeafIndex = <span class="built_in">FindLeaf</span>(key);</span><br><span class="line">            Node Leaf;</span><br><span class="line">            File.<span class="built_in">seekg</span>(<span class="built_in">GetNodeAddress</span>(LeafIndex));</span><br><span class="line">            File.<span class="built_in">read</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(&amp;Leaf), <span class="built_in">sizeof</span>(Node));</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">1</span>; i &lt;= Leaf.Num; ++i)</span><br><span class="line">                <span class="keyword">if</span>(key == Leaf.Data[i].first) <span class="comment">// already exist</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">CloseFile</span>();</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="built_in">PutSize</span>(<span class="built_in">GetSize</span>() + <span class="number">1</span>);</span><br><span class="line">            Leaf.<span class="built_in">LeafInsert</span>(<span class="built_in">DataType</span>(key, value));</span><br><span class="line">            <span class="keyword">if</span>(Leaf.Num &lt;= CAPACITY_LEAF) <span class="comment">// don&#x27;t need to split</span></span><br><span class="line">            &#123;</span><br><span class="line">                File.<span class="built_in">seekp</span>(<span class="built_in">GetNodeAddress</span>(LeafIndex));</span><br><span class="line">                File.<span class="built_in">write</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(&amp;Leaf), <span class="built_in">sizeof</span>(Node));</span><br><span class="line">                <span class="built_in">CloseFile</span>();</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// split Leaf to NewLeaf</span></span><br><span class="line">            <span class="type">size_t</span> NewLeafIndex = <span class="built_in">NewNodeIndex</span>(), LeafOriginalNextIndex = Leaf.NextLeafIndex;</span><br><span class="line">            <span class="function">Node <span class="title">NewLeaf</span><span class="params">(LEAF)</span>, LeafOriginalNext</span>;</span><br><span class="line">            File.<span class="built_in">seekg</span>(<span class="built_in">GetNodeAddress</span>(LeafOriginalNextIndex));</span><br><span class="line">            File.<span class="built_in">read</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(&amp;LeafOriginalNext), <span class="built_in">sizeof</span>(Node));</span><br><span class="line">            NewLeaf.PrevLeafIndex = LeafIndex;</span><br><span class="line">            NewLeaf.NextLeafIndex = Leaf.NextLeafIndex;</span><br><span class="line">            Leaf.NextLeafIndex = NewLeafIndex;</span><br><span class="line">            LeafOriginalNext.PrevLeafIndex = NewLeafIndex;</span><br><span class="line">            File.<span class="built_in">seekp</span>(<span class="built_in">GetNodeAddress</span>(LeafOriginalNextIndex));</span><br><span class="line">            File.<span class="built_in">write</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(&amp;LeafOriginalNext), <span class="built_in">sizeof</span>(Node));</span><br><span class="line">            NewLeaf.Num = (Leaf.Num + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            Leaf.Num /= <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">1</span>; i &lt;= NewLeaf.Num; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                NewLeaf.Data[i] = Leaf.Data[Leaf.Num + i];</span><br><span class="line">                Leaf.Data[Leaf.Num + i] = <span class="built_in">DataType</span>();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// adjust up</span></span><br><span class="line">            <span class="keyword">if</span>(Leaf.FatherIndex == <span class="number">-1</span>) <span class="comment">// root is LEAF</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">size_t</span> NewRootIndex = <span class="built_in">NewNodeIndex</span>();</span><br><span class="line">                <span class="function">Node <span class="title">NewRoot</span><span class="params">(INTERNAL)</span></span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// adjust Leaf, NewRoot and NewLeaf</span></span><br><span class="line">                NewRoot.Num = <span class="number">1</span>;</span><br><span class="line">                NewRoot.ChildIndex[<span class="number">0</span>] = LeafIndex;</span><br><span class="line">                NewRoot.ChildIndex[<span class="number">1</span>] = NewLeafIndex;</span><br><span class="line">                NewRoot.KeyIndex[<span class="number">1</span>] = NewLeaf.Data[<span class="number">1</span>].first;</span><br><span class="line">                Leaf.FatherIndex = NewRootIndex;</span><br><span class="line">                NewLeaf.FatherIndex = NewRootIndex;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// write to file</span></span><br><span class="line">                <span class="built_in">PutRootIndex</span>(NewRootIndex);</span><br><span class="line">                File.<span class="built_in">seekp</span>(<span class="built_in">GetNodeAddress</span>(LeafIndex));</span><br><span class="line">                File.<span class="built_in">write</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(&amp;Leaf), <span class="built_in">sizeof</span>(Node));</span><br><span class="line">                File.<span class="built_in">seekp</span>(<span class="built_in">GetNodeAddress</span>(NewRootIndex));</span><br><span class="line">                File.<span class="built_in">write</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(&amp;NewRoot), <span class="built_in">sizeof</span>(Node));</span><br><span class="line">                File.<span class="built_in">seekp</span>(<span class="built_in">GetNodeAddress</span>(NewLeafIndex));</span><br><span class="line">                File.<span class="built_in">write</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(&amp;NewLeaf), <span class="built_in">sizeof</span>(Node));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                NewLeaf.FatherIndex = Leaf.FatherIndex;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// write to file</span></span><br><span class="line">                File.<span class="built_in">seekp</span>(<span class="built_in">GetNodeAddress</span>(LeafIndex));</span><br><span class="line">                File.<span class="built_in">write</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(&amp;Leaf), <span class="built_in">sizeof</span>(Node));</span><br><span class="line">                File.<span class="built_in">seekp</span>(<span class="built_in">GetNodeAddress</span>(NewLeafIndex));</span><br><span class="line">                File.<span class="built_in">write</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(&amp;NewLeaf), <span class="built_in">sizeof</span>(Node));</span><br><span class="line"></span><br><span class="line">                <span class="type">size_t</span> FatherIndex = Leaf.FatherIndex;</span><br><span class="line">                Node Father;</span><br><span class="line">                File.<span class="built_in">seekg</span>(<span class="built_in">GetNodeAddress</span>(FatherIndex));</span><br><span class="line">                File.<span class="built_in">read</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(&amp;Father), <span class="built_in">sizeof</span>(Node));</span><br><span class="line"></span><br><span class="line">                Key SplitExtraKey = NewLeaf.Data[<span class="number">1</span>].first;</span><br><span class="line">                <span class="type">size_t</span> PosIndex, NewPosIndex = NewLeafIndex;</span><br><span class="line">                Node Pos;</span><br><span class="line">                <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// adjust Father</span></span><br><span class="line">                    Father.<span class="built_in">InternalInsert</span>(SplitExtraKey, NewPosIndex);</span><br><span class="line">                    <span class="keyword">if</span>(Father.Num &lt; ORDER) <span class="comment">// don&#x27;t need to continue to split</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        File.<span class="built_in">seekp</span>(<span class="built_in">GetNodeAddress</span>(FatherIndex));</span><br><span class="line">                        File.<span class="built_in">write</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(&amp;Father), <span class="built_in">sizeof</span>(Node));</span><br><span class="line">                        <span class="built_in">CloseFile</span>();</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// level up</span></span><br><span class="line">                    Pos = Father;</span><br><span class="line">                    PosIndex = FatherIndex;</span><br><span class="line">                    FatherIndex = Pos.FatherIndex;</span><br><span class="line">                    <span class="keyword">if</span>(FatherIndex == <span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">                    <span class="function">Node <span class="title">NewPos</span><span class="params">(INTERNAL)</span></span>;</span><br><span class="line">                    NewPosIndex = <span class="built_in">NewNodeIndex</span>();</span><br><span class="line">                    File.<span class="built_in">seekg</span>(<span class="built_in">GetNodeAddress</span>(FatherIndex));</span><br><span class="line">                    File.<span class="built_in">read</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(&amp;Father), <span class="built_in">sizeof</span>(Node));</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// split Pos to NewPos and record SplitExtraKey</span></span><br><span class="line">                    SplitExtraKey = Pos.KeyIndex[Pos.Num / <span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line">                    Pos.KeyIndex[Pos.Num / <span class="number">2</span> + <span class="number">1</span>] = <span class="built_in">Key</span>();</span><br><span class="line">                    NewPos.Num = (Pos.Num - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">                    Pos.Num /= <span class="number">2</span>;</span><br><span class="line">                    NewPos.FatherIndex = Pos.FatherIndex;</span><br><span class="line">                    NewPos.ChildIndex[<span class="number">0</span>] = Pos.ChildIndex[Pos.Num + <span class="number">1</span>];</span><br><span class="line">                    Pos.ChildIndex[Pos.Num + <span class="number">1</span>] = <span class="built_in">size_t</span>();</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">1</span>; i &lt;= NewPos.Num; ++i)</span><br><span class="line">                    &#123;</span><br><span class="line">                        NewPos.KeyIndex[i] = Pos.KeyIndex[Pos.Num + <span class="number">1</span> + i];</span><br><span class="line">                        NewPos.ChildIndex[i] = Pos.ChildIndex[Pos.Num + <span class="number">1</span> + i];</span><br><span class="line">                        Pos.KeyIndex[Pos.Num + <span class="number">1</span> + i] = <span class="built_in">Key</span>();</span><br><span class="line">                        Pos.ChildIndex[Pos.Num + <span class="number">1</span> + i] = <span class="built_in">size_t</span>();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// adjust Father of NewPos&#x27;s Child</span></span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">0</span>; i &lt;= NewPos.Num; ++i)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="type">size_t</span> TmpIndex = NewPos.ChildIndex[i];</span><br><span class="line">                        Node Tmp;</span><br><span class="line">                        File.<span class="built_in">seekg</span>(<span class="built_in">GetNodeAddress</span>(TmpIndex));</span><br><span class="line">                        File.<span class="built_in">read</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(&amp;Tmp), <span class="built_in">sizeof</span>(Node));</span><br><span class="line">                        Tmp.FatherIndex = NewPosIndex;</span><br><span class="line">                        File.<span class="built_in">seekp</span>(<span class="built_in">GetNodeAddress</span>(TmpIndex));</span><br><span class="line">                        File.<span class="built_in">write</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(&amp;Tmp), <span class="built_in">sizeof</span>(Node));</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// write to file</span></span><br><span class="line">                    File.<span class="built_in">seekp</span>(<span class="built_in">GetNodeAddress</span>(PosIndex));</span><br><span class="line">                    File.<span class="built_in">write</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(&amp;Pos), <span class="built_in">sizeof</span>(Node));</span><br><span class="line">                    File.<span class="built_in">seekp</span>(<span class="built_in">GetNodeAddress</span>(NewPosIndex));</span><br><span class="line">                    File.<span class="built_in">write</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(&amp;NewPos), <span class="built_in">sizeof</span>(Node));</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * split the root</span></span><br><span class="line"><span class="comment">                 * only run when tree height will increase</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="type">size_t</span> NewRootIndex = <span class="built_in">NewNodeIndex</span>();</span><br><span class="line">                NewPosIndex = <span class="built_in">NewNodeIndex</span>();</span><br><span class="line">                <span class="function">Node <span class="title">NewRoot</span><span class="params">(INTERNAL)</span>, <span class="title">NewPos</span><span class="params">(INTERNAL)</span></span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// split Pos to NewPos and record SplitExtraKey</span></span><br><span class="line">                SplitExtraKey = Pos.KeyIndex[Pos.Num / <span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line">                Pos.KeyIndex[Pos.Num / <span class="number">2</span> + <span class="number">1</span>] = <span class="built_in">Key</span>();</span><br><span class="line">                NewPos.Num = (Pos.Num - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">                Pos.Num /= <span class="number">2</span>;</span><br><span class="line">                Pos.FatherIndex = NewRootIndex;</span><br><span class="line">                NewPos.FatherIndex = NewRootIndex;</span><br><span class="line">                NewPos.ChildIndex[<span class="number">0</span>] = Pos.ChildIndex[Pos.Num + <span class="number">1</span>];</span><br><span class="line">                Pos.ChildIndex[Pos.Num + <span class="number">1</span>] = <span class="built_in">size_t</span>();</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">1</span>; i &lt;= NewPos.Num; ++i)</span><br><span class="line">                &#123;</span><br><span class="line">                    NewPos.KeyIndex[i] = Pos.KeyIndex[Pos.Num + <span class="number">1</span> + i];</span><br><span class="line">                    NewPos.ChildIndex[i] = Pos.ChildIndex[Pos.Num + <span class="number">1</span> + i];</span><br><span class="line">                    Pos.KeyIndex[Pos.Num + <span class="number">1</span> + i] = <span class="built_in">Key</span>();</span><br><span class="line">                    Pos.ChildIndex[Pos.Num + <span class="number">1</span> + i] = <span class="built_in">size_t</span>();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// adjust Father of NewPos&#x27;s Child</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">0</span>; i &lt;= NewPos.Num; ++i)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">size_t</span> TmpIndex = NewPos.ChildIndex[i];</span><br><span class="line">                    Node Tmp;</span><br><span class="line">                    File.<span class="built_in">seekg</span>(<span class="built_in">GetNodeAddress</span>(TmpIndex));</span><br><span class="line">                    File.<span class="built_in">read</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(&amp;Tmp), <span class="built_in">sizeof</span>(Node));</span><br><span class="line">                    Tmp.FatherIndex = NewPosIndex;</span><br><span class="line">                    File.<span class="built_in">seekp</span>(<span class="built_in">GetNodeAddress</span>(TmpIndex));</span><br><span class="line">                    File.<span class="built_in">write</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(&amp;Tmp), <span class="built_in">sizeof</span>(Node));</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// adjust NewRoot</span></span><br><span class="line">                NewRoot.Num = <span class="number">1</span>;</span><br><span class="line">                NewRoot.ChildIndex[<span class="number">0</span>] = PosIndex;</span><br><span class="line">                NewRoot.ChildIndex[<span class="number">1</span>] = NewPosIndex;</span><br><span class="line">                NewRoot.KeyIndex[<span class="number">1</span>] = SplitExtraKey;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// write to file</span></span><br><span class="line">                <span class="built_in">PutRootIndex</span>(NewRootIndex);</span><br><span class="line">                File.<span class="built_in">seekp</span>(<span class="built_in">GetNodeAddress</span>(PosIndex));</span><br><span class="line">                File.<span class="built_in">write</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(&amp;Pos), <span class="built_in">sizeof</span>(Node));</span><br><span class="line">                File.<span class="built_in">seekp</span>(<span class="built_in">GetNodeAddress</span>(NewPosIndex));</span><br><span class="line">                File.<span class="built_in">write</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(&amp;NewPos), <span class="built_in">sizeof</span>(Node));</span><br><span class="line">                File.<span class="built_in">seekp</span>(<span class="built_in">GetNodeAddress</span>(NewRootIndex));</span><br><span class="line">                File.<span class="built_in">write</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(&amp;NewRoot), <span class="built_in">sizeof</span>(Node));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">CloseFile</span>();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// return true if modify successfully, else return false</span></span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">modify</span><span class="params">(<span class="type">const</span> Key &amp;key, <span class="type">const</span> Value &amp;value)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="built_in">OpenFile</span>();</span><br><span class="line">            <span class="type">bool</span> ret = <span class="literal">false</span>;</span><br><span class="line">            <span class="type">size_t</span> ModifyIndex = <span class="built_in">FindLeaf</span>(key);</span><br><span class="line">            Node Pos;</span><br><span class="line">            File.<span class="built_in">seekg</span>(<span class="built_in">GetNodeAddress</span>(ModifyIndex));</span><br><span class="line">            File.<span class="built_in">read</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(&amp;Pos), <span class="built_in">sizeof</span>(Node));</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">1</span>; i &lt;= Pos.Num; ++i)</span><br><span class="line">                <span class="keyword">if</span>(key == Pos.Data[i].first)</span><br><span class="line">                    &#123; Pos.Data[i].second = value; ret = <span class="literal">true</span>; &#125;</span><br><span class="line">            File.<span class="built_in">seekp</span>(<span class="built_in">GetNodeAddress</span>(ModifyIndex));</span><br><span class="line">            File.<span class="built_in">write</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(&amp;Pos), <span class="built_in">sizeof</span>(Node));</span><br><span class="line">            <span class="built_in">CloseFile</span>();</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// return the Value corresponding to the Key</span></span><br><span class="line">        <span class="comment">// return Value() if Key doesn&#x27;t exist</span></span><br><span class="line">        <span class="function">Value <span class="title">at</span><span class="params">(<span class="type">const</span> Key &amp;key)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="built_in">OpenFile</span>();</span><br><span class="line">            Value ret = <span class="built_in">Value</span>();</span><br><span class="line">            <span class="type">size_t</span> AtIndex = <span class="built_in">FindLeaf</span>(key);</span><br><span class="line">            Node Pos;</span><br><span class="line">            File.<span class="built_in">seekg</span>(<span class="built_in">GetNodeAddress</span>(AtIndex));</span><br><span class="line">            File.<span class="built_in">read</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(&amp;Pos), <span class="built_in">sizeof</span>(Node));</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">1</span>; i &lt;= Pos.Num; ++i)</span><br><span class="line">                <span class="keyword">if</span>(key == Pos.Data[i].first)</span><br><span class="line">                    &#123; ret = Pos.Data[i].second; <span class="keyword">break</span>; &#125;</span><br><span class="line">            <span class="built_in">CloseFile</span>();</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// return true if erase successfully, else return false</span></span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">erase</span><span class="params">(<span class="type">const</span> Key &amp;key)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="built_in">OpenFile</span>();</span><br><span class="line"></span><br><span class="line">            <span class="type">size_t</span> LeafIndex = <span class="built_in">FindLeaf</span>(key);</span><br><span class="line">            Node Leaf;</span><br><span class="line">            File.<span class="built_in">seekg</span>(<span class="built_in">GetNodeAddress</span>(LeafIndex));</span><br><span class="line">            File.<span class="built_in">read</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(&amp;Leaf), <span class="built_in">sizeof</span>(Node));</span><br><span class="line">            <span class="type">bool</span> ExistFlag = <span class="literal">false</span>, AdjustFlag = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">1</span>; i &lt;= Leaf.Num; ++i)</span><br><span class="line">                <span class="keyword">if</span>(key == Leaf.Data[i].first)</span><br><span class="line">                &#123;</span><br><span class="line">                    ExistFlag = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">if</span>(i == <span class="number">1</span>) AdjustFlag = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">if</span>(!ExistFlag) <span class="comment">// don&#x27;t exist</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">CloseFile</span>();</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// get Leaf&#x27;s Father, PrevLeaf and NextLeaf</span></span><br><span class="line">            <span class="type">size_t</span> FatherIndex = Leaf.FatherIndex,</span><br><span class="line">                   PrevLeafIndex = Leaf.PrevLeafIndex,</span><br><span class="line">                   NextLeafIndex = Leaf.NextLeafIndex;</span><br><span class="line">            Node Father, PrevLeaf, NextLeaf;</span><br><span class="line">            File.<span class="built_in">seekg</span>(<span class="built_in">GetNodeAddress</span>(FatherIndex));</span><br><span class="line">            File.<span class="built_in">read</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(&amp;Father), <span class="built_in">sizeof</span>(Node));</span><br><span class="line">            File.<span class="built_in">seekg</span>(<span class="built_in">GetNodeAddress</span>(PrevLeafIndex));</span><br><span class="line">            File.<span class="built_in">read</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(&amp;PrevLeaf), <span class="built_in">sizeof</span>(Node));</span><br><span class="line">            File.<span class="built_in">seekg</span>(<span class="built_in">GetNodeAddress</span>(NextLeafIndex));</span><br><span class="line">            File.<span class="built_in">read</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(&amp;NextLeaf), <span class="built_in">sizeof</span>(Node));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// erase data whose first == key in Leaf</span></span><br><span class="line">            <span class="built_in">PutSize</span>(<span class="built_in">GetSize</span>() - <span class="number">1</span>);</span><br><span class="line">            Leaf.<span class="built_in">LeafErase</span>(key);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// adjust KeyIndex corresponding to Leaf</span></span><br><span class="line">            <span class="keyword">if</span>(AdjustFlag)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(LeafIndex == Father.ChildIndex[<span class="number">0</span>]) <span class="comment">// adjust KeyIndex in Leaf&#x27;s ancestor (not Father)</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">size_t</span> TmpIndex;</span><br><span class="line">                    Node Tmp = Father;</span><br><span class="line">                    <span class="keyword">while</span>(Tmp.FatherIndex != <span class="number">-1</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="type">bool</span> BreakFlag = <span class="literal">false</span>;</span><br><span class="line">                        TmpIndex = Tmp.FatherIndex;</span><br><span class="line">                        File.<span class="built_in">seekg</span>(<span class="built_in">GetNodeAddress</span>(TmpIndex));</span><br><span class="line">                        File.<span class="built_in">read</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(&amp;Tmp), <span class="built_in">sizeof</span>(Node));</span><br><span class="line">                        <span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">1</span>; i &lt;= Tmp.Num; ++i)</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="keyword">if</span>(Tmp.KeyIndex[i] == key)</span><br><span class="line">                            &#123;</span><br><span class="line">                                Tmp.KeyIndex[i] = Leaf.Data[<span class="number">1</span>].first;</span><br><span class="line">                                File.<span class="built_in">seekp</span>(<span class="built_in">GetNodeAddress</span>(TmpIndex));</span><br><span class="line">                                File.<span class="built_in">write</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(&amp;Tmp), <span class="built_in">sizeof</span>(Node));</span><br><span class="line">                                BreakFlag = <span class="literal">true</span>;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span> <span class="keyword">if</span>(Tmp.KeyIndex[i] &gt; key) <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span>(BreakFlag) <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="comment">// adjust KeyIndex in Leaf&#x27;s Father</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">1</span>; i &lt;= Father.Num; ++i)</span><br><span class="line">                        <span class="keyword">if</span>(Father.KeyIndex[i] == key)</span><br><span class="line">                        &#123;</span><br><span class="line">                            Father.KeyIndex[i] = Leaf.Data[<span class="number">1</span>].first;</span><br><span class="line">                            File.<span class="built_in">seekp</span>(<span class="built_in">GetNodeAddress</span>(FatherIndex));</span><br><span class="line">                            File.<span class="built_in">write</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(&amp;Father), <span class="built_in">sizeof</span>(Node));</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// don&#x27;t need to operate</span></span><br><span class="line">            <span class="keyword">if</span>(LeafIndex == <span class="built_in">GetRootIndex</span>() || Leaf.Num &gt;= (CAPACITY_LEAF + <span class="number">1</span>) / <span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                File.<span class="built_in">seekp</span>(<span class="built_in">GetNodeAddress</span>(LeafIndex));</span><br><span class="line">                File.<span class="built_in">write</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(&amp;Leaf), <span class="built_in">sizeof</span>(Node));</span><br><span class="line">                <span class="built_in">CloseFile</span>();</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(PrevLeaf.FatherIndex == Leaf.FatherIndex &amp;&amp; PrevLeaf.Num &gt; (CAPACITY_LEAF + <span class="number">1</span>) / <span class="number">2</span>) <span class="comment">// adopt from PrevLeaf</span></span><br><span class="line">            &#123;</span><br><span class="line">                DataType AdoptData = PrevLeaf.Data[PrevLeaf.Num];</span><br><span class="line">                PrevLeaf.Data[PrevLeaf.Num--] = <span class="built_in">DataType</span>();</span><br><span class="line">                Leaf.<span class="built_in">LeafInsert</span>(AdoptData);</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">1</span>; i &lt;= Father.Num; ++i)</span><br><span class="line">                    <span class="keyword">if</span>(Father.KeyIndex[i] == Leaf.Data[<span class="number">2</span>].first)</span><br><span class="line">                    &#123;</span><br><span class="line">                        Father.KeyIndex[i] = Leaf.Data[<span class="number">1</span>].first;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// write to file</span></span><br><span class="line">                File.<span class="built_in">seekp</span>(<span class="built_in">GetNodeAddress</span>(LeafIndex));</span><br><span class="line">                File.<span class="built_in">write</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(&amp;Leaf), <span class="built_in">sizeof</span>(Node));</span><br><span class="line">                File.<span class="built_in">seekp</span>(<span class="built_in">GetNodeAddress</span>(PrevLeafIndex));</span><br><span class="line">                File.<span class="built_in">write</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(&amp;PrevLeaf), <span class="built_in">sizeof</span>(Node));</span><br><span class="line">                File.<span class="built_in">seekp</span>(<span class="built_in">GetNodeAddress</span>(FatherIndex));</span><br><span class="line">                File.<span class="built_in">write</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(&amp;Father), <span class="built_in">sizeof</span>(Node));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(NextLeaf.FatherIndex == Leaf.FatherIndex &amp;&amp; NextLeaf.Num &gt; (CAPACITY_LEAF + <span class="number">1</span>) / <span class="number">2</span>) <span class="comment">// adopt from NextLeaf</span></span><br><span class="line">            &#123;</span><br><span class="line">                DataType AdoptData = NextLeaf.Data[<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">1</span>; i &lt;= NextLeaf.Num - <span class="number">1</span>; ++i)</span><br><span class="line">                    NextLeaf.Data[i] = NextLeaf.Data[i + <span class="number">1</span>];</span><br><span class="line">                NextLeaf.Data[NextLeaf.Num--] = <span class="built_in">DataType</span>();</span><br><span class="line">                Leaf.Data[++Leaf.Num] = AdoptData;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">1</span>; i &lt;= Father.Num; ++i)</span><br><span class="line">                    <span class="keyword">if</span>(Father.KeyIndex[i] == AdoptData.first)</span><br><span class="line">                    &#123;</span><br><span class="line">                        Father.KeyIndex[i] = NextLeaf.Data[<span class="number">1</span>].first;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// write to file</span></span><br><span class="line">                File.<span class="built_in">seekp</span>(<span class="built_in">GetNodeAddress</span>(LeafIndex));</span><br><span class="line">                File.<span class="built_in">write</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(&amp;Leaf), <span class="built_in">sizeof</span>(Node));</span><br><span class="line">                File.<span class="built_in">seekp</span>(<span class="built_in">GetNodeAddress</span>(NextLeafIndex));</span><br><span class="line">                File.<span class="built_in">write</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(&amp;NextLeaf), <span class="built_in">sizeof</span>(Node));</span><br><span class="line">                File.<span class="built_in">seekp</span>(<span class="built_in">GetNodeAddress</span>(FatherIndex));</span><br><span class="line">                File.<span class="built_in">write</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(&amp;Father), <span class="built_in">sizeof</span>(Node));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">// have to merge</span></span><br><span class="line">            &#123;</span><br><span class="line">                Key MergeKey = Leaf.Data[<span class="number">1</span>].first;</span><br><span class="line">                <span class="keyword">if</span>(PrevLeaf.FatherIndex != Leaf.FatherIndex) <span class="comment">// Leaf is Father&#x27;s first Child</span></span><br><span class="line">                &#123;</span><br><span class="line">                    MergeKey = NextLeaf.Data[<span class="number">1</span>].first;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// adopt from NextLeaf</span></span><br><span class="line">                    DataType AdoptData = NextLeaf.Data[<span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">1</span>; i &lt;= NextLeaf.Num - <span class="number">1</span>; ++i)</span><br><span class="line">                        NextLeaf.Data[i] = NextLeaf.Data[i + <span class="number">1</span>];</span><br><span class="line">                    NextLeaf.Data[NextLeaf.Num--] = <span class="built_in">DataType</span>();</span><br><span class="line">                    Leaf.Data[++Leaf.Num] = AdoptData;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// modify Leaf, PrevLeaf, NextLeaf</span></span><br><span class="line">                    PrevLeafIndex = LeafIndex;</span><br><span class="line">                    PrevLeaf = Leaf;</span><br><span class="line">                    LeafIndex = NextLeafIndex;</span><br><span class="line">                    Leaf = NextLeaf;</span><br><span class="line">                    NextLeafIndex = Father.ChildIndex[<span class="number">2</span>];</span><br><span class="line">                    File.<span class="built_in">seekg</span>(<span class="built_in">GetNodeAddress</span>(NextLeafIndex));</span><br><span class="line">                    File.<span class="built_in">read</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(&amp;NextLeaf), <span class="built_in">sizeof</span>(Node));</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// merge Leaf to PrevLeaf</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">1</span>; i &lt;= Leaf.Num; ++i)</span><br><span class="line">                    PrevLeaf.Data[PrevLeaf.Num + i] = Leaf.Data[i];</span><br><span class="line">                PrevLeaf.Num += Leaf.Num;</span><br><span class="line"></span><br><span class="line">                NextLeaf.PrevLeafIndex = Leaf.PrevLeafIndex;</span><br><span class="line">                PrevLeaf.NextLeafIndex = Leaf.NextLeafIndex;</span><br><span class="line">                Leaf.<span class="built_in">Reset</span>();</span><br><span class="line">                Leaf.NextEmptyIndex = <span class="built_in">GetEmptyIndex</span>();</span><br><span class="line">                <span class="built_in">PutEmptyIndex</span>(LeafIndex);</span><br><span class="line">                File.<span class="built_in">seekp</span>(<span class="built_in">GetNodeAddress</span>(LeafIndex));</span><br><span class="line">                File.<span class="built_in">write</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(&amp;Leaf), <span class="built_in">sizeof</span>(Node));</span><br><span class="line">                File.<span class="built_in">seekp</span>(<span class="built_in">GetNodeAddress</span>(PrevLeafIndex));</span><br><span class="line">                File.<span class="built_in">write</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(&amp;PrevLeaf), <span class="built_in">sizeof</span>(Node));</span><br><span class="line">                File.<span class="built_in">seekp</span>(<span class="built_in">GetNodeAddress</span>(NextLeafIndex));</span><br><span class="line">                File.<span class="built_in">write</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(&amp;NextLeaf), <span class="built_in">sizeof</span>(Node));</span><br><span class="line"></span><br><span class="line">                <span class="type">size_t</span> PosIndex;</span><br><span class="line">                Node Pos;</span><br><span class="line">                <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    Father.<span class="built_in">InternalErase</span>(MergeKey);</span><br><span class="line">                    <span class="keyword">if</span>((FatherIndex != <span class="built_in">GetRootIndex</span>() &amp;&amp; Father.Num &gt;= (ORDER - <span class="number">1</span>) / <span class="number">2</span>) || (FatherIndex == <span class="built_in">GetRootIndex</span>() &amp;&amp; Father.Num &gt;= <span class="number">1</span>))</span><br><span class="line">                    &#123;</span><br><span class="line">                        File.<span class="built_in">seekp</span>(<span class="built_in">GetNodeAddress</span>(FatherIndex));</span><br><span class="line">                        File.<span class="built_in">write</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(&amp;Father), <span class="built_in">sizeof</span>(Node));</span><br><span class="line">                        <span class="built_in">CloseFile</span>();</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    Pos = Father;</span><br><span class="line">                    PosIndex = FatherIndex;</span><br><span class="line">                    FatherIndex = Pos.FatherIndex;</span><br><span class="line">                    <span class="keyword">if</span>(FatherIndex == <span class="number">-1</span>) <span class="keyword">break</span>; <span class="comment">// Pos is Root</span></span><br><span class="line">                    File.<span class="built_in">seekg</span>(<span class="built_in">GetNodeAddress</span>(FatherIndex));</span><br><span class="line">                    File.<span class="built_in">read</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(&amp;Father), <span class="built_in">sizeof</span>(Node));</span><br><span class="line"></span><br><span class="line">                    Key FatherKeyLeft = <span class="built_in">Key</span>(), FatherKeyRight = <span class="built_in">Key</span>();</span><br><span class="line">                    <span class="type">size_t</span> PrevPosIndex = <span class="number">-1</span>, NextPosIndex = <span class="number">-1</span>;</span><br><span class="line">                    Node PrevPos, NextPos;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">0</span>; i &lt;= Father.Num; ++i)</span><br><span class="line">                        <span class="keyword">if</span>(Father.ChildIndex[i] == PosIndex)</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="keyword">if</span>(i)</span><br><span class="line">                            &#123;</span><br><span class="line">                                PrevPosIndex = Father.ChildIndex[i - <span class="number">1</span>];</span><br><span class="line">                                FatherKeyLeft = Father.KeyIndex[i];</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">if</span>(i != Father.Num)</span><br><span class="line">                            &#123;</span><br><span class="line">                                NextPosIndex = Father.ChildIndex[i + <span class="number">1</span>];</span><br><span class="line">                                FatherKeyRight = Father.KeyIndex[i + <span class="number">1</span>];</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    <span class="keyword">if</span>(PrevPosIndex != <span class="number">-1</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        File.<span class="built_in">seekg</span>(<span class="built_in">GetNodeAddress</span>(PrevPosIndex));</span><br><span class="line">                        File.<span class="built_in">read</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(&amp;PrevPos), <span class="built_in">sizeof</span>(Node));</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(NextPosIndex != <span class="number">-1</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        File.<span class="built_in">seekg</span>(<span class="built_in">GetNodeAddress</span>(NextPosIndex));</span><br><span class="line">                        File.<span class="built_in">read</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(&amp;NextPos), <span class="built_in">sizeof</span>(Node));</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span>(PrevPosIndex != <span class="number">-1</span> &amp;&amp; PrevPos.FatherIndex == Pos.FatherIndex &amp;&amp; PrevPos.Num &gt; (ORDER - <span class="number">1</span>) / <span class="number">2</span>) <span class="comment">// adopt from PrevPos</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">// adjust PrevPos</span></span><br><span class="line">                        Key AdoptKey = PrevPos.KeyIndex[PrevPos.Num];</span><br><span class="line">                        <span class="type">size_t</span> AdoptIndex = PrevPos.ChildIndex[PrevPos.Num];</span><br><span class="line">                        PrevPos.KeyIndex[PrevPos.Num] = <span class="built_in">Key</span>();</span><br><span class="line">                        PrevPos.ChildIndex[PrevPos.Num] = <span class="built_in">size_t</span>();</span><br><span class="line">                        --PrevPos.Num;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// adjust Pos</span></span><br><span class="line">                        <span class="keyword">for</span>(<span class="type">size_t</span> i = ++Pos.Num; i &gt;= <span class="number">1</span>; --i)</span><br><span class="line">                        &#123;</span><br><span class="line">                            Pos.KeyIndex[i] = Pos.KeyIndex[i - <span class="number">1</span>];</span><br><span class="line">                            Pos.ChildIndex[i] = Pos.ChildIndex[i - <span class="number">1</span>];</span><br><span class="line">                        &#125;</span><br><span class="line">                        Pos.KeyIndex[<span class="number">1</span>] = FatherKeyLeft;</span><br><span class="line">                        Pos.ChildIndex[<span class="number">0</span>] = AdoptIndex;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// adjust Father</span></span><br><span class="line">                        <span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">1</span>; i &lt;= Father.Num; ++i)</span><br><span class="line">                            <span class="keyword">if</span>(Father.KeyIndex[i] == FatherKeyLeft)</span><br><span class="line">                                &#123; Father.KeyIndex[i] = AdoptKey; <span class="keyword">break</span>; &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// adjust FatherIndex of the Node corresponding to AdoptIndex</span></span><br><span class="line">                        Node Adopt;</span><br><span class="line">                        File.<span class="built_in">seekg</span>(<span class="built_in">GetNodeAddress</span>(AdoptIndex));</span><br><span class="line">                        File.<span class="built_in">read</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(&amp;Adopt), <span class="built_in">sizeof</span>(Node));</span><br><span class="line">                        Adopt.FatherIndex = PosIndex;</span><br><span class="line">                        File.<span class="built_in">seekp</span>(<span class="built_in">GetNodeAddress</span>(AdoptIndex));</span><br><span class="line">                        File.<span class="built_in">write</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(&amp;Adopt), <span class="built_in">sizeof</span>(Node));</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// write to file</span></span><br><span class="line">                        File.<span class="built_in">seekp</span>(<span class="built_in">GetNodeAddress</span>(PosIndex));</span><br><span class="line">                        File.<span class="built_in">write</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(&amp;Pos), <span class="built_in">sizeof</span>(Node));</span><br><span class="line">                        File.<span class="built_in">seekp</span>(<span class="built_in">GetNodeAddress</span>(PrevPosIndex));</span><br><span class="line">                        File.<span class="built_in">write</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(&amp;PrevPos), <span class="built_in">sizeof</span>(Node));</span><br><span class="line">                        File.<span class="built_in">seekp</span>(<span class="built_in">GetNodeAddress</span>(FatherIndex));</span><br><span class="line">                        File.<span class="built_in">write</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(&amp;Father), <span class="built_in">sizeof</span>(Node));</span><br><span class="line"></span><br><span class="line">                        <span class="built_in">CloseFile</span>();</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(NextPosIndex != <span class="number">-1</span> &amp;&amp; NextPos.FatherIndex == Pos.FatherIndex &amp;&amp; NextPos.Num &gt; (ORDER - <span class="number">1</span>) / <span class="number">2</span>) <span class="comment">// adopt from NextPos</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">// adjust NextPos</span></span><br><span class="line">                        Key AdoptKey = NextPos.KeyIndex[<span class="number">1</span>];</span><br><span class="line">                        <span class="type">size_t</span> AdoptIndex = NextPos.ChildIndex[<span class="number">0</span>];</span><br><span class="line">                        NextPos.ChildIndex[<span class="number">0</span>] = NextPos.ChildIndex[<span class="number">1</span>];</span><br><span class="line">                        <span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">1</span>; i &lt;= NextPos.Num - <span class="number">1</span>; ++i)</span><br><span class="line">                        &#123;</span><br><span class="line">                            NextPos.KeyIndex[i] = NextPos.KeyIndex[i + <span class="number">1</span>];</span><br><span class="line">                            NextPos.ChildIndex[i] = NextPos.ChildIndex[i + <span class="number">1</span>];</span><br><span class="line">                        &#125;</span><br><span class="line">                        NextPos.KeyIndex[NextPos.Num] = <span class="built_in">Key</span>();</span><br><span class="line">                        NextPos.ChildIndex[NextPos.Num] = <span class="built_in">size_t</span>();</span><br><span class="line">                        --NextPos.Num;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// adjust Pos</span></span><br><span class="line">                        ++Pos.Num;</span><br><span class="line">                        Pos.KeyIndex[Pos.Num] = FatherKeyRight;</span><br><span class="line">                        Pos.ChildIndex[Pos.Num] = AdoptIndex;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// adjust Father</span></span><br><span class="line">                        <span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">1</span>; i &lt;= Father.Num; ++i)</span><br><span class="line">                            <span class="keyword">if</span>(Father.KeyIndex[i] == FatherKeyRight)</span><br><span class="line">                                &#123; Father.KeyIndex[i] = AdoptKey; <span class="keyword">break</span>; &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// adjust FatherIndex of the Node corresponding to AdoptIndex</span></span><br><span class="line">                        Node Adopt;</span><br><span class="line">                        File.<span class="built_in">seekg</span>(<span class="built_in">GetNodeAddress</span>(AdoptIndex));</span><br><span class="line">                        File.<span class="built_in">read</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(&amp;Adopt), <span class="built_in">sizeof</span>(Node));</span><br><span class="line">                        Adopt.FatherIndex = PosIndex;</span><br><span class="line">                        File.<span class="built_in">seekp</span>(<span class="built_in">GetNodeAddress</span>(AdoptIndex));</span><br><span class="line">                        File.<span class="built_in">write</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(&amp;Adopt), <span class="built_in">sizeof</span>(Node));</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// write to file</span></span><br><span class="line">                        File.<span class="built_in">seekp</span>(<span class="built_in">GetNodeAddress</span>(PosIndex));</span><br><span class="line">                        File.<span class="built_in">write</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(&amp;Pos), <span class="built_in">sizeof</span>(Node));</span><br><span class="line">                        File.<span class="built_in">seekp</span>(<span class="built_in">GetNodeAddress</span>(NextPosIndex));</span><br><span class="line">                        File.<span class="built_in">write</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(&amp;NextPos), <span class="built_in">sizeof</span>(Node));</span><br><span class="line">                        File.<span class="built_in">seekp</span>(<span class="built_in">GetNodeAddress</span>(FatherIndex));</span><br><span class="line">                        File.<span class="built_in">write</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(&amp;Father), <span class="built_in">sizeof</span>(Node));</span><br><span class="line"></span><br><span class="line">                        <span class="built_in">CloseFile</span>();</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="comment">// continue to merge</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">if</span>(PrevPosIndex != <span class="number">-1</span> &amp;&amp; PrevPos.FatherIndex == Pos.FatherIndex) <span class="comment">// merge Pos to PrevPos</span></span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="comment">// adjust PrevPos</span></span><br><span class="line">                            MergeKey = FatherKeyLeft;</span><br><span class="line">                            PrevPos.KeyIndex[PrevPos.Num + <span class="number">1</span>] = FatherKeyLeft;</span><br><span class="line">                            PrevPos.ChildIndex[PrevPos.Num + <span class="number">1</span>] = Pos.ChildIndex[<span class="number">0</span>];</span><br><span class="line">                            <span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">1</span>; i &lt;= Pos.Num; ++i)</span><br><span class="line">                            &#123;</span><br><span class="line">                                PrevPos.KeyIndex[PrevPos.Num + <span class="number">1</span> + i] = Pos.KeyIndex[i];</span><br><span class="line">                                PrevPos.ChildIndex[PrevPos.Num + <span class="number">1</span> + i] = Pos.ChildIndex[i];</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            PrevPos.Num += Pos.Num + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// adjust Father of Pos&#x27;s Child</span></span><br><span class="line">                            <span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">0</span>; i &lt;= Pos.Num; ++i)</span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="type">size_t</span> TmpIndex = Pos.ChildIndex[i];</span><br><span class="line">                                Node Tmp;</span><br><span class="line">                                File.<span class="built_in">seekg</span>(<span class="built_in">GetNodeAddress</span>(TmpIndex));</span><br><span class="line">                                File.<span class="built_in">read</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(&amp;Tmp), <span class="built_in">sizeof</span>(Node));</span><br><span class="line">                                Tmp.FatherIndex = PrevPosIndex;</span><br><span class="line">                                File.<span class="built_in">seekp</span>(<span class="built_in">GetNodeAddress</span>(TmpIndex));</span><br><span class="line">                                File.<span class="built_in">write</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(&amp;Tmp), <span class="built_in">sizeof</span>(Node));</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// adjust Pos</span></span><br><span class="line">                            Pos.<span class="built_in">Reset</span>();</span><br><span class="line">                            Pos.NextEmptyIndex = <span class="built_in">GetEmptyIndex</span>();</span><br><span class="line">                            <span class="built_in">PutEmptyIndex</span>(PosIndex);</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// write to file</span></span><br><span class="line">                            File.<span class="built_in">seekp</span>(<span class="built_in">GetNodeAddress</span>(PosIndex));</span><br><span class="line">                            File.<span class="built_in">write</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(&amp;Pos), <span class="built_in">sizeof</span>(Node));</span><br><span class="line">                            File.<span class="built_in">seekp</span>(<span class="built_in">GetNodeAddress</span>(PrevPosIndex));</span><br><span class="line">                            File.<span class="built_in">write</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(&amp;PrevPos), <span class="built_in">sizeof</span>(Node));</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> <span class="comment">// merge Pos to NextPos</span></span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="comment">// adjust NextPos</span></span><br><span class="line">                            MergeKey = FatherKeyLeft;</span><br><span class="line">                            <span class="keyword">for</span>(<span class="type">size_t</span> i = NextPos.Num; i &gt;= <span class="number">1</span>; --i)</span><br><span class="line">                            &#123;</span><br><span class="line">                                NextPos.KeyIndex[Pos.Num + i + <span class="number">1</span>] = NextPos.KeyIndex[i];</span><br><span class="line">                                NextPos.ChildIndex[Pos.Num + i + <span class="number">1</span>] = NextPos.ChildIndex[i];</span><br><span class="line">                            &#125;</span><br><span class="line">                            NextPos.KeyIndex[Pos.Num + <span class="number">1</span>] = FatherKeyRight;</span><br><span class="line">                            NextPos.ChildIndex[Pos.Num + <span class="number">1</span>] = NextPos.ChildIndex[<span class="number">0</span>];</span><br><span class="line">                            NextPos.ChildIndex[<span class="number">0</span>] = Pos.ChildIndex[<span class="number">0</span>];</span><br><span class="line">                            <span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">1</span>; i &lt;= Pos.Num; ++i)</span><br><span class="line">                            &#123;</span><br><span class="line">                                NextPos.KeyIndex[i] = Pos.KeyIndex[i];</span><br><span class="line">                                NextPos.ChildIndex[i] = Pos.ChildIndex[i];</span><br><span class="line">                            &#125;</span><br><span class="line">                            NextPos.Num += Pos.Num + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// adjust Father of Pos&#x27;s Child</span></span><br><span class="line">                            <span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">0</span>; i &lt;= Pos.Num; ++i)</span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="type">size_t</span> TmpIndex = Pos.ChildIndex[i];</span><br><span class="line">                                Node Tmp;</span><br><span class="line">                                File.<span class="built_in">seekg</span>(<span class="built_in">GetNodeAddress</span>(TmpIndex));</span><br><span class="line">                                File.<span class="built_in">read</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(&amp;Tmp), <span class="built_in">sizeof</span>(Node));</span><br><span class="line">                                Tmp.FatherIndex = NextPosIndex;</span><br><span class="line">                                File.<span class="built_in">seekp</span>(<span class="built_in">GetNodeAddress</span>(TmpIndex));</span><br><span class="line">                                File.<span class="built_in">write</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(&amp;Tmp), <span class="built_in">sizeof</span>(Node));</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// adjust Pos</span></span><br><span class="line">                            Pos.<span class="built_in">Reset</span>();</span><br><span class="line">                            Pos.NextEmptyIndex = <span class="built_in">GetEmptyIndex</span>();</span><br><span class="line">                            <span class="built_in">PutEmptyIndex</span>(PosIndex);</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// write to file</span></span><br><span class="line">                            File.<span class="built_in">seekp</span>(<span class="built_in">GetNodeAddress</span>(PosIndex));</span><br><span class="line">                            File.<span class="built_in">write</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(&amp;Pos), <span class="built_in">sizeof</span>(Node));</span><br><span class="line">                            File.<span class="built_in">seekp</span>(<span class="built_in">GetNodeAddress</span>(NextPosIndex));</span><br><span class="line">                            File.<span class="built_in">write</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(&amp;NextPos), <span class="built_in">sizeof</span>(Node));</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * delete the root</span></span><br><span class="line"><span class="comment">                 * only run when tree height will decrease</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="type">size_t</span> ChildIndex = Pos.ChildIndex[<span class="number">0</span>];</span><br><span class="line">                Node Child;</span><br><span class="line">                File.<span class="built_in">seekg</span>(<span class="built_in">GetNodeAddress</span>(ChildIndex));</span><br><span class="line">                File.<span class="built_in">read</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(&amp;Child), <span class="built_in">sizeof</span>(Node));</span><br><span class="line">                Child.FatherIndex = <span class="number">-1</span>;</span><br><span class="line">                <span class="built_in">PutRootIndex</span>(ChildIndex);</span><br><span class="line">                Pos.<span class="built_in">Reset</span>();</span><br><span class="line">                Pos.NextEmptyIndex = <span class="built_in">GetEmptyIndex</span>();</span><br><span class="line">                <span class="built_in">PutEmptyIndex</span>(PosIndex);</span><br><span class="line">                File.<span class="built_in">seekp</span>(<span class="built_in">GetNodeAddress</span>(PosIndex));</span><br><span class="line">                File.<span class="built_in">write</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(&amp;Pos), <span class="built_in">sizeof</span>(Node));</span><br><span class="line">                File.<span class="built_in">seekp</span>(<span class="built_in">GetNodeAddress</span>(ChildIndex));</span><br><span class="line">                File.<span class="built_in">write</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(&amp;Child), <span class="built_in">sizeof</span>(Node));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">CloseFile</span>();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">iterator</span></span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">BPlusTree</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line">            BPlusTree* ptr;</span><br><span class="line">            <span class="type">size_t</span> NodeIndex;</span><br><span class="line">            <span class="type">size_t</span> OrderNum;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            <span class="built_in">iterator</span>() :<span class="built_in">ptr</span>(<span class="literal">nullptr</span>), <span class="built_in">NodeIndex</span>(<span class="number">-1</span>), <span class="built_in">OrderNum</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">            <span class="built_in">iterator</span>(BPlusTree* ptr_param, <span class="type">size_t</span> NodeIndex_param, <span class="type">size_t</span> OrderNum_param)</span><br><span class="line">                :<span class="built_in">ptr</span>(ptr_param), <span class="built_in">NodeIndex</span>(NodeIndex_param), <span class="built_in">OrderNum</span>(OrderNum_param) &#123;&#125;</span><br><span class="line">            <span class="built_in">iterator</span>(<span class="type">const</span> iterator&amp; other)</span><br><span class="line">                :<span class="built_in">ptr</span>(other.ptr), <span class="built_in">NodeIndex</span>(other.NodeIndex), <span class="built_in">OrderNum</span>(other.OrderNum) &#123;&#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// modify by iterator</span></span><br><span class="line">            <span class="function"><span class="type">bool</span> <span class="title">modify</span><span class="params">(<span class="type">const</span> Value&amp; value)</span></span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                Node Leaf = ptr-&gt;<span class="built_in">IterGetNode</span>(NodeIndex);</span><br><span class="line">                Leaf.Data[OrderNum].second = value;</span><br><span class="line">                ptr-&gt;<span class="built_in">IterPutNode</span>(Leaf, NodeIndex);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function">Key <span class="title">getKey</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                Node Leaf = ptr-&gt;<span class="built_in">IterGetNode</span>(NodeIndex);</span><br><span class="line">                <span class="keyword">return</span> Leaf.Data[OrderNum].first;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function">Value <span class="title">getValue</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                Node Leaf = ptr-&gt;<span class="built_in">IterGetNode</span>(NodeIndex);</span><br><span class="line">                <span class="keyword">return</span> Leaf.Data[OrderNum].second;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// iter++</span></span><br><span class="line">            iterator <span class="keyword">operator</span>++(<span class="type">int</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(ptr == <span class="literal">nullptr</span>)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="built_in">invalid_iterator</span>();</span><br><span class="line">                iterator ret = *<span class="keyword">this</span>;</span><br><span class="line">                Node Leaf = ptr-&gt;<span class="built_in">IterGetNode</span>(NodeIndex);</span><br><span class="line">                <span class="keyword">if</span>(OrderNum &lt; Leaf.Num) ++OrderNum;</span><br><span class="line">                <span class="keyword">else</span> NodeIndex = Leaf.NextLeafIndex, OrderNum = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">return</span> ret;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// ++iter</span></span><br><span class="line">            iterator&amp; <span class="keyword">operator</span>++()</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(ptr == <span class="literal">nullptr</span>)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="built_in">invalid_iterator</span>();</span><br><span class="line">                Node Leaf = ptr-&gt;<span class="built_in">IterGetNode</span>(NodeIndex);</span><br><span class="line">                <span class="keyword">if</span>(OrderNum &lt; Leaf.Num) ++OrderNum;</span><br><span class="line">                <span class="keyword">else</span> NodeIndex = Leaf.NextLeafIndex, OrderNum = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// iter--</span></span><br><span class="line">            iterator <span class="keyword">operator</span>--(<span class="type">int</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(ptr == <span class="literal">nullptr</span>)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="built_in">invalid_iterator</span>();</span><br><span class="line">                iterator ret = *<span class="keyword">this</span>;</span><br><span class="line">                Node Leaf = ptr-&gt;<span class="built_in">IterGetNode</span>(NodeIndex);</span><br><span class="line">                <span class="keyword">if</span>(OrderNum &gt; <span class="number">1</span>) --OrderNum;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    Node PrevLeaf = ptr-&gt;<span class="built_in">IterGetNode</span>(Leaf.PrevLeafIndex);</span><br><span class="line">                    NodeIndex = Leaf.PrevLeafIndex, OrderNum = PrevLeaf.Num;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> ret;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// --iter</span></span><br><span class="line">            iterator&amp; <span class="keyword">operator</span>--()</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(ptr == <span class="literal">nullptr</span>)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="built_in">invalid_iterator</span>();</span><br><span class="line">                Node Leaf = ptr-&gt;<span class="built_in">IterGetNode</span>(NodeIndex);</span><br><span class="line">                <span class="keyword">if</span>(OrderNum &gt; <span class="number">1</span>) --OrderNum;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    Node PrevLeaf = ptr-&gt;<span class="built_in">IterGetNode</span>(Leaf.PrevLeafIndex);</span><br><span class="line">                    NodeIndex = Leaf.PrevLeafIndex, OrderNum = PrevLeaf.Num;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> iterator&amp; rhs) <span class="type">const</span></span><br><span class="line">                &#123; <span class="keyword">return</span> ptr == rhs.ptr &amp;&amp; NodeIndex == rhs.NodeIndex &amp;&amp; OrderNum == rhs.OrderNum; &#125;</span><br><span class="line">            <span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> iterator&amp; rhs) <span class="type">const</span></span><br><span class="line">                &#123; <span class="keyword">return</span> ptr != rhs.ptr || NodeIndex != rhs.NodeIndex || OrderNum != rhs.OrderNum; &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">iterator</span>(<span class="keyword">this</span>, <span class="built_in">IterGetNode</span>(<span class="number">-2</span>).NextLeafIndex, <span class="number">1</span>);&#125;</span><br><span class="line">        <span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">iterator</span>(<span class="keyword">this</span>, <span class="number">-3</span>, <span class="number">1</span>); &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">iterator <span class="title">find</span><span class="params">(<span class="type">const</span> Key &amp;key)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="built_in">OpenFile</span>();</span><br><span class="line">            <span class="type">size_t</span> LeafIndex = <span class="built_in">FindLeaf</span>(key);</span><br><span class="line">            Node Leaf;</span><br><span class="line">            File.<span class="built_in">seekg</span>(<span class="built_in">GetNodeAddress</span>(LeafIndex));</span><br><span class="line">            File.<span class="built_in">read</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(&amp;Leaf), <span class="built_in">sizeof</span>(Node));</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">1</span>; i &lt;= Leaf.Num; ++i)</span><br><span class="line">                <span class="keyword">if</span>(Leaf.Data[i].first == key)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">CloseFile</span>();</span><br><span class="line">                    <span class="keyword">return</span> <span class="built_in">iterator</span>(<span class="keyword">this</span>, LeafIndex, i);</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">runtime_error</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// return an iterator whose key is the smallest key greater or equal than &#x27;key&#x27;</span></span><br><span class="line">        <span class="function">iterator <span class="title">lower_bound</span><span class="params">(<span class="type">const</span> Key &amp;key)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="built_in">OpenFile</span>();</span><br><span class="line">            <span class="type">size_t</span> LeafIndex = <span class="built_in">FindLeaf</span>(key);</span><br><span class="line">            Node Leaf;</span><br><span class="line">            File.<span class="built_in">seekg</span>(<span class="built_in">GetNodeAddress</span>(LeafIndex));</span><br><span class="line">            File.<span class="built_in">read</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(&amp;Leaf), <span class="built_in">sizeof</span>(Node));</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">1</span>; i &lt;= Leaf.Num; ++i)</span><br><span class="line">                <span class="keyword">if</span>(Leaf.Data[i].first &gt;= key)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">CloseFile</span>();</span><br><span class="line">                    <span class="keyword">return</span> <span class="built_in">iterator</span>(<span class="keyword">this</span>, LeafIndex, i);</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="built_in">CloseFile</span>();</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">iterator</span>(<span class="keyword">this</span>, Leaf.NextLeafIndex, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125; <span class="comment">// namespace sjtu</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//SJTU_BPLUSTREE_HPP</span></span></span><br></pre></td></tr></table></figure>
<h1 id="课程感想">课程感想</h1>
<p>  虽然在选这门课之前就已经听说了这个班级要求很高，于是提前做好了迎接挑战心理准备，但实际学习过程中还是压力满满，加之遇上疫情变成了线上课，更是不一样的体验，3学分的课至少花费了十几学分的精力。不过回想起来虽然一直被虐，但是真的收获满满，不论是平时作业和机考让我这个没怎么学过OI的蒟蒻学到了很多以前只听过名字的算法，还是这篇博文的大作业让我初步认识到什么叫面向对象，毕竟在这门课之前，迭代器对我而言还是一个非常陌生的概念。</p>
<p>  在这门课里，我不仅学到了很多数据结构的知识，还增加了我对CS的热爱，有了许多全新的体验：第一次从惊叹题目的复杂到慢慢实现正确的算法，第一次在一无所有的框架中写了超过千行的代码，第一次体会到debug一整天都毫无收获的烦躁，第一次收获写出大作业的成就感……在对着电脑屏幕苦苦挣扎若干小时后，屏幕上跳出的AC真的是最好的慰藉，那一刻的喜悦之情真的胜过千言。总之，感谢yyu老师的悉心教导，感谢各位助教出题、讲解、答疑！</p>
]]></content>
      <categories>
        <category>CS学习之路</category>
      </categories>
  </entry>
  <entry>
    <title>missing-semester 学习笔记</title>
    <url>/2022/06/20/missing-semester-notes/</url>
    <content><![CDATA[<p>本文是MIT课程missing-semester的学习笔记，这是一门介绍计算机工具的课，课时比较短，约为11小时，但涵盖的内容比较丰富。</p>
<span id="more"></span>
<h1 id="class-1-the-shell-教程地址">Class 1: The Shell (<a href="https://missing.csail.mit.edu/2020/course-shell/">教程地址</a>)</h1>
<h2 id="shell-基础指令">shell 基础指令</h2>
<h3 id="显示当前时间">显示当前时间</h3>
<ul>
<li><strong>命令：</strong><code>date</code><br>
</li>
<li><strong>示例：</strong> <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">date</span>   <span class="comment"># Sat Jan 1 00:00:00 2022</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="打印内容到命令行">打印内容到命令行</h3>
<ul>
<li><strong>命令：</strong><code>echo [输出内容]</code><br>
</li>
<li><strong>示例：</strong> <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$HOME</span>   <span class="comment"># /c/Users/MeteorVanish</span></span><br><span class="line"><span class="built_in">echo</span> Hello\ world!   <span class="comment"># Hello world!</span></span><br></pre></td></tr></table></figure> &gt; 注：若参数中若含有
<code>' '</code>，需用 <code>'\ '</code> 代替或使用引号包裹</li>
</ul>
<h3 id="查看程序地址">查看程序地址</h3>
<ul>
<li><strong>命令：</strong><code>which [程序名]</code></li>
<li><strong>示例：</strong> <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">which</span> <span class="built_in">echo</span>   <span class="comment"># /usr/bin/echo</span></span><br></pre></td></tr></table></figure> &gt; 注：地址分隔符在
<code>Linux</code> 和 <code>macOS</code> 下是 <code>/</code>，在
<code>Windows</code> 下是 <code>\</code></li>
</ul>
<h3 id="查看当前工作目录">查看当前工作目录</h3>
<ul>
<li><strong>命令：</strong><code>pwd</code> [<strong>p</strong>rint
<strong>w</strong>orking <strong>d</strong>irectory]</li>
<li><strong>示例：</strong> <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">pwd</span>   <span class="comment"># /c/Users/MeteorVanish</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="切换当前工作目录">切换当前工作目录</h3>
<ul>
<li><strong>命令：</strong><code>cd [绝对/相对路径]</code>
[<strong>c</strong>hange <strong>d</strong>irectory]
<ul>
<li>绝对路径：<code>cd /xxx</code></li>
<li>相对路径：<code>.</code> 表示当前目录，<code>..</code>
表示上级目录，<code>-</code> 表示之前所在目录</li>
</ul></li>
<li><strong>示例：</strong> <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /home   <span class="comment"># 切换到 home</span></span><br><span class="line"><span class="built_in">cd</span> ./bin   <span class="comment"># 切换到 home 目录下的 bin 目录</span></span><br><span class="line"><span class="built_in">cd</span> ..   <span class="comment"># 切换到上级目录</span></span><br><span class="line"><span class="built_in">cd</span> -   <span class="comment"># 切换到之前所在目录</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="查看当前工作目录下文件夹">查看当前工作目录下文件（夹）</h3>
<ul>
<li><p><strong>命令：</strong><code>ls [ 打印目录（默认当前工作目录）]</code>
[<strong>l</strong>i<strong>s</strong>t]</p></li>
<li><p><strong>示例：</strong> <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#（当前在 /）</span></span><br><span class="line"><span class="built_in">ls</span>   <span class="comment"># bin dev home ...</span></span><br><span class="line"><span class="built_in">ls</span> sys   <span class="comment"># block  bus  class  dev  devices  firmware  fs  kernel  module  power</span></span><br></pre></td></tr></table></figure></p></li>
<li><p><code>ls -l</code></p>
<ul>
<li>权限信息：共十位
<ul>
<li>第一位：<code>d</code> 代表文件夹， <code>l</code> 代表链接文件，
<code>-</code> 代表普通文件</li>
<li>第二至十位：三位一组，各组分别表示了文件所有者、用户组以及其他所有人的权限，每位依次为
<code>r (read)</code>，<code>w (write)</code>，<code>x (execute)</code>，分别代表查看、修改、执行/搜索权限，不具备相应权限则对应位置为
<code>-</code>
<ul>
<li>对文件夹而言，<code>r</code>
权限表示是否能查看文件夹内包含哪些文件，<code>w</code>
权限表示是否能重命名、增加、删除文件夹内文件，<code>x</code>
权限表示是否能够进入文件夹</li>
<li>想要访问一个文件需要具有其所有父文件夹的搜索权限</li>
</ul></li>
</ul></li>
</ul></li>
</ul>
<h3 id="重命名或移动文件夹">重命名或移动文件（夹）</h3>
<ul>
<li><strong>命令：</strong><code>mv [原文件（夹）名] [新文件（夹）名]</code>，<code>mv [原文件（夹）地址] [新文件（夹）地址]</code>
(<strong>m</strong>o<strong>v</strong>e)</li>
<li><strong>示例：</strong> <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mv</span> old.md new.md   <span class="comment"># 将 old.md 重命名为 new.md</span></span><br><span class="line"><span class="built_in">mv</span> test.md ../dir2/test.md   <span class="comment">#（当前在 dir1 ）将 dir1 中的 test.md 移动到 dir2 中</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="拷贝文件夹">拷贝文件（夹）</h3>
<ul>
<li><strong>命令：</strong><code>cp [原文件（夹）名] [新文件（夹）名]</code>
[<strong>c</strong>o<strong>p</strong>y]</li>
<li><strong>示例：</strong> <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cp</span> test.md ../dir2/test.md   <span class="comment">#（当前在 dir1 ）将 dir1 中的 test.md 拷贝到 dir2 中</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="删除文件夹">删除文件（夹）</h3>
<ul>
<li><strong>命令：</strong><code>rm [文件名]</code>，<code>rm -r [文件夹名]</code>，<code>rmdir [文件夹名]</code>（仅当文件夹为空时有效）[<strong>r</strong>e<strong>m</strong>ove
(<strong>dir</strong>ectory)]</li>
<li><strong>示例：</strong> <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">rm</span> test.md   <span class="comment"># 删除文件 test.md</span></span><br><span class="line"><span class="built_in">rm</span> -r dir1   <span class="comment"># 删除文件夹 dir1 及其中的所有文件</span></span><br><span class="line"><span class="built_in">rmdir</span> dir2   <span class="comment"># 删除空文件夹 dir2</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="创建文件夹">创建文件夹</h3>
<ul>
<li><strong>命令：</strong><code>mkdir [文件夹名]</code>
[<strong>m</strong>a<strong>k</strong>e <strong>dir</strong>ectory]</li>
<li><strong>示例：</strong> <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> dir2   <span class="comment"># 在当前目录新建名为 dir2 的文件夹</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="查看指令用法">查看指令用法</h3>
<ul>
<li><strong>命令：</strong><code>man [指令]</code>
[<strong>man</strong>ual]，<code>[指令] --help</code></li>
</ul>
<h2 id="输入输出流">输入输出流</h2>
<h3 id="输入输出流重定向">输入输出流重定向</h3>
<ul>
<li><strong>命令：</strong><code>&lt; file</code>，<code>&gt; file</code>
（覆盖rewrite），<code>&gt;&gt; file</code> (追加append)</li>
<li><strong>示例：</strong> <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> hello &gt; hello.txt   <span class="comment"># 在 hello.txt 文件（不存在就新建）中写入 &quot;hello&quot;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="显示文件内容">显示文件内容</h3>
<ul>
<li><strong>命令：</strong><code>cat [文件名/输入流]</code>
[con<strong>cat</strong>enate]</li>
<li><strong>示例：</strong> <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> hello.txt   <span class="comment"># hello</span></span><br><span class="line"><span class="built_in">cat</span> &lt; hello.txt   <span class="comment"># hello</span></span><br><span class="line"><span class="built_in">cat</span> &lt; hello.txt &gt; hello2.txt   <span class="comment"># 在 hello2.txt 中写入 hello.txt 的内容（在 hello2.txt 不存在时作用与 cp 相同）</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="连接运算符-pipe">连接运算符 <code>|</code> (pipe)</h3>
<ul>
<li><strong>命令：</strong><code>[前一条命令] | [后一条命令]</code></li>
<li><strong>功能：</strong>将前一条指令的输出作为后一条指令的输入</li>
<li><strong>示例：</strong> <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ls</span> -l / | <span class="built_in">tail</span> -n1   <span class="comment"># drwxr-xr-x 1 MeteorVanish 197609       0 Jan 31 15:31 usr（&quot;ls -l /&quot; 输出内容的最后一行）</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="将输入流重定向至输出流">将输入流重定向至输出流</h3>
<ul>
<li><strong>命令：</strong><code>[输入流] tee [输出流]</code></li>
<li><strong>功能：</strong>在不进入 <code>root</code> 终端时使用
<code>sudo</code> 指令修改内核变量的值</li>
<li><strong>示例：</strong> <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> 500 | sudo <span class="built_in">tee</span> brightness   <span class="comment"># 将屏幕亮度更改为 500（等效于在 root 终端下 &quot;echo 500 &gt; brightness&quot;）</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="杂项">杂项</h2>
<ul>
<li><strong>清空命令行快捷键：</strong><code>Ctrl + L</code></li>
<li><strong>进入 <code>root</code> 终端：</strong><code>sudo su</code>
（需要输入密码）</li>
<li><strong>退出 <code>root</code> 终端：</strong><code>exit</code></li>
</ul>
<h2 id="练习">练习</h2>
<p><strong>1. 查看 <code>shell</code> 是否满足要求</strong>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$SHELL</span></span><br></pre></td></tr></table></figure></p>
<p><strong>2. 在 <code>/tmp</code> 下新建一个名为 <code>missing</code>
的文件夹</strong> <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /tmp</span><br><span class="line"><span class="built_in">mkdir</span> missing</span><br></pre></td></tr></table></figure></p>
<p><strong>3. 用 <code>man</code> 查看程序 <code>touch</code>
的使用手册</strong> <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">man <span class="built_in">touch</span></span><br></pre></td></tr></table></figure></p>
<p><strong>4. 用 <code>touch</code> 在 <code>missing</code>
文件夹中新建一个叫 <code>semester</code> 的文件</strong>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">touch</span> semester</span><br></pre></td></tr></table></figure></p>
<p><strong>5. 将以下内容一行一行地写入 <code>semester</code>
文件：</strong></p>
<blockquote>
<p>#!/bin/sh<br>
curl --head --silent https://missing.csail.mit.edu</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;#!/bin/sh&#x27;</span> &gt; semester</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;curl --head --silent https://missing.csail.mit.edu&#x27;</span> &gt;&gt; semester</span><br></pre></td></tr></table></figure>
<p><strong>6. 尝试执行 <code>semester</code>
文件，如果程序无法执行，请使用 <code>ls</code>
命令来获取信息并理解其不能执行的原因</strong></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">./semester</span><br><span class="line"><span class="built_in">ls</span> -l</span><br></pre></td></tr></table></figure>
<p><strong>7. 通过显式地打开 <code>sh</code> 解释器来运行命令，将文件
<code>semester</code> 作为第一个参数</strong> <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sh semester</span><br></pre></td></tr></table></figure></p>
<p><strong>8. 查看 <code>chmod</code> 的手册</strong> <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">man <span class="built_in">chmod</span></span><br></pre></td></tr></table></figure></p>
<p><strong>9. 使用 <code>chmod</code> 命令改变权限，使
<code>./semester</code> 能够成功执行</strong> <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">chmod</span> 777 semester</span><br><span class="line">./semester</span><br></pre></td></tr></table></figure></p>
<p><strong>10. 使用 <code>|</code> 和 <code>&gt;</code> ，将
<code>semester</code> 文件输出的最后更改日期信息，写入主目录下的
<code>last-modified.txt</code> 的文件中</strong> <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">./semester | grep last-modified &gt; ~/last-modified.txt</span><br></pre></td></tr></table></figure></p>
<p><strong>11. 写一段命令来从 <code>/sys</code>
中获取笔记本的电量信息</strong></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /sys/class/power_supply/battery</span><br><span class="line"><span class="built_in">cat</span> capacity</span><br></pre></td></tr></table></figure>
<h1 id="class-2-shell-tools-and-scripting-教程地址">Class 2: Shell Tools
and Scripting (<a href="https://missing.csail.mit.edu/2020/shell-tools/">教程地址</a>)</h1>
<h2 id="shell-脚本bash">Shell 脚本（bash）</h2>
<h3 id="复制变量">复制变量</h3>
<ul>
<li><strong>示例：</strong> <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">foo=bar   <span class="comment">#（没有空格）</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="转义">转义</h3>
<ul>
<li>单引号 <code>'</code> 不会转义，双引号 <code>"</code> 会转义</li>
<li><strong>示例：</strong> <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;Value is $foo&#x27;</span>   <span class="comment"># Value is $foo</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Value is <span class="variable">$foo</span>&quot;</span>   <span class="comment"># Value is bar</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="bash-中的特殊变量"><code>bash</code> 中的特殊变量</h3>
<ul>
<li><code>$0</code>：脚本名</li>
<li><code>$1</code> - <code>$9</code>：脚本的第一个至第九个参数</li>
<li><code>$@</code>：所有参数</li>
<li><code>$#</code>：参数个数</li>
<li><code>$?</code>：前一个命令的返回值
<ul>
<li>返回值0表示正常执行，其他所有非0的返回值都表示有错误发生。</li>
<li><code>true</code> 的返回码永远是 <code>0</code>，<code>false</code>
的返回码永远是 <code>1</code></li>
<li>返回值可以搭配 <code>&amp;&amp;</code>（与运算符）和
<code>||</code>（或运算符）使用，均为<strong>短路运算符</strong>
<ul>
<li><strong>示例：</strong> <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="literal">false</span> || <span class="built_in">echo</span> <span class="string">&quot;false with ||&quot;</span>   <span class="comment"># false with ||</span></span><br><span class="line"><span class="literal">true</span> || <span class="built_in">echo</span> <span class="string">&quot;true with ||&quot;</span>   <span class="comment">#（无）</span></span><br><span class="line"><span class="literal">false</span> &amp;&amp; <span class="built_in">echo</span> <span class="string">&quot;false with &amp;&amp;&quot;</span>   <span class="comment">#（无）</span></span><br><span class="line"><span class="literal">true</span> &amp;&amp; <span class="built_in">echo</span> <span class="string">&quot;true with &amp;&amp;&quot;</span>   <span class="comment"># true with &amp;&amp;</span></span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul></li>
<li><code>$$</code>：当前脚本的进程识别码</li>
<li><code>!!</code>：完整的上一条命令，包括参数。
<ul>
<li>常见应用：当你因为权限不足执行命令失败时，可以使用
<code>sudo !!</code> 再尝试一次。</li>
</ul></li>
<li><code>$_</code>：上一条命令的最后一个参数
<ul>
<li>如果你正在使用的是交互式 shell，你可以通过按下 <code>Esc</code>
之后键入 <code>.</code> 来获取这个值。</li>
</ul></li>
</ul>
<h3 id="命令替换command-substitution">命令替换（command
substitution）</h3>
<ul>
<li>通过 <code>$( CMD )</code> 这样的方式来执行 <code>CMD</code>
这个命令时，它的输出结果会替换掉 <code>$( CMD )</code></li>
<li><strong>示例：</strong> <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;We are in <span class="subst">$(pwd)</span>&quot;</span>   <span class="comment"># We are in /home/meteorvanish</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="进程替换process-substitution">进程替换（process
substitution）</h3>
<ul>
<li><code>&lt;( CMD )</code> 会执行 <code>CMD</code>
并将结果输出到一个临时文件中，并将 <code>&lt;( CMD )</code>
替换成临时文件名</li>
<li><strong>示例：</strong> <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> &lt;(<span class="built_in">pwd</span>)   <span class="comment"># /home/meteorvanish</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="脚本示例">脚本示例</h3>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Starting program at <span class="subst">$(date)</span>&quot;</span> <span class="comment"># Date will be substituted</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Running program <span class="variable">$0</span> with <span class="variable">$#</span> arguments with pid $$&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> <span class="string">&quot;<span class="variable">$@</span>&quot;</span>; <span class="keyword">do</span></span><br><span class="line">    grep foobar <span class="string">&quot;<span class="variable">$file</span>&quot;</span> &gt; /dev/null 2&gt; /dev/null</span><br><span class="line">    <span class="comment"># When pattern is not found, grep has exit status 1</span></span><br><span class="line">    <span class="comment"># We redirect STDOUT and STDERR to a null register since we do not care about them</span></span><br><span class="line">    <span class="keyword">if</span> [[ $? -ne 0 ]]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;File <span class="variable">$file</span> does not have any foobar, adding one&quot;</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;# foobar&quot;</span> &gt;&gt; <span class="string">&quot;<span class="variable">$file</span>&quot;</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>作用：</strong>搜索作为参数的文件内容，若不存在
<code>foobar</code> 内容就在结尾加上一行 <code># foobar</code></li>
<li><strong>注：</strong>
<ul>
<li>第7行 <code>&gt;</code> 为 stdout 输出流，<code>2&gt;</code> 为
stderr 输出流</li>
<li>第10行比较 <code>$?</code> 是否等于 <code>0</code> 是使用了
<code>-ne</code> 指令，<code>bash</code> 中更多类似的比较指令可以通过
<code>man test</code> 查看。</li>
<li><em>在bash中进行比较时，尽量使用双方括号 <code>[[ ]]</code>
而不是单方括号
<code>[ ]</code>，这样会降低犯错的几率，尽管这样并不能兼容
<code>sh</code>，更详细的说明参见<a href="http://mywiki.wooledge.org/BashFAQ/031">这里</a>。</em>
<strong><em>（暂未理解含义）</em></strong></li>
</ul></li>
</ul>
<h3 id="通配globbing">通配（globbing）</h3>
<ul>
<li>通配符 <code>?</code> 匹配一个字符，<code>*</code> 匹配任意个字符
<ul>
<li><strong>示例：</strong>对于文件
<code>foo</code>，<code>foo1</code>，<code>foo2</code>，<code>foo10</code>
和 <code>bar</code>，<code>rm foo?</code> 这条命令会删除
<code>foo1</code> 和 <code>foo2</code>，而 <code>rm foo*</code> 则会删除
<code>bar</code> 之外的所有文件</li>
</ul></li>
<li>花括号 <code>&#123; &#125;</code>
能够将一系列包含一段公共子串的指令进行自动展开，以便进行批量处理文件
<ul>
<li><strong>示例：</strong> <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> project&#123;1,2&#125;   <span class="comment"># 创建文件夹 project1 和 project2</span></span><br><span class="line"><span class="built_in">touch</span> project&#123;1,2&#125;/test&#123;1..3&#125;   <span class="comment"># 在文件夹 project1 和 project2 下分别创建文件 test1，test2 和 test3</span></span><br><span class="line"><span class="built_in">touch</span> project1/x project2/y</span><br><span class="line">diff &lt;(<span class="built_in">ls</span> project1) &lt;(<span class="built_in">ls</span> project2)</span><br><span class="line"><span class="comment"># 4c4</span></span><br><span class="line"><span class="comment"># &lt; x</span></span><br><span class="line"><span class="comment"># ---</span></span><br><span class="line"><span class="comment"># &gt; y</span></span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul>
<h2 id="杂项-1">杂项</h2>
<ul>
<li>同一行的多个命令可以用 <code>;</code> 分隔</li>
</ul>
]]></content>
      <categories>
        <category>CS学习之路</category>
      </categories>
  </entry>
</search>
